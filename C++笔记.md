#                                                                                                                                                                                                                                                                                                                                                                                                                                                             C++笔记

## 一、概述

### 1、编译、运行程序

程序文件通常被称之为源文件（source file），C++源文件后缀一般为`.cpp`或`.cc`或`.cxx`等等

C++是静态类型语言，即在编译阶段检查类型（type checking）

默认情况下，GNU编译器的**编译**命令为：

​		`g++ 源文件名.cpp -o 可执行文件名（无后缀）    `

​		`例：g++ prog1.cpp -o prog1       //-o prog1是编译器参数，指定了可执行文件名`

在UNIX操作系统中，生成的可执行文件**无后缀**；在windows中后缀为`.exe`。

若省略了`-o prog1`参数，即不指定可执行文件名，在UNIX系统中编译器会**自动生成一个名为`a.out`的可执行文件**；在windows中会生成一个名为`a.exe`的可执行文件。

**运行**可执行文件：

在windows中可以忽略文件的扩展名`.exe`，输入可执行文件名即可运行。一般需要显示指出文件的位置：   			`.\prog1`       //代表在当前目录下

在UNIX中需要使用全文件名，包括文件扩展名：

​			`./a.out`

注：在系统中可以使用echo命令可以查看main函数的返回值



### 2、初识输入输出

C++没有定义任何输入输出语句，取而代之，它包含了一个全面的**标准库（standard library）**来提供IO机制以及很多其他设施。

`iostream`库很常见，包括两个基础类型`istream`和`ostream`，分别表示**输入流和输出流**。

一个流就是一个字符序列，是从IO设备读出或进行写入的。流即代表字符序列随着时间的推移会顺序生成或消耗字符。

`#include <iostream>`    // #include指令和头文件名字必须写在同一行中

#### 标准输入输出对象

标准输入(standard input)  ：`cin`     它是`istream`类型的对象  

标准输出(standard output)：`cout`    它是`ostream`类型的对象

标准库还定义了其他两个ostream对象：

​		`cerr`     用来输出警告和错误消息，也被称为标准错误（standard error）

​		`clog`     用来输出程序运行时的一般性信息

#### 向流写入数据

**输出运算符：`<<`**          **<<  operator**

`std::cout << "hello world" << std::endl;`

在C/C++中，一个表达式产生一个计算结果

**<<运算符**接收两个运算对象，左侧的运算对象必须是一个ostream对象，即**输出流对象**，右侧是要打印的值。

此运算符将给定的值写到给定的ostream对象中。

**它的计算结果**就是其左侧的运算对象，即写入给定值之后的ostream对象

在上例中使用了两次`<<`，由于它返回的是左侧运算对象，因此第一个运算符的结果成为了第二个运算符的左侧运算对象。这样就可以将输出请求进行连接。当然也可以分开写：

```c++
std::cout << "hello world";  //string literal 字符串字面值常量
std::cout << std::endl; //打印endl，并且换行

//std::cout的解释
//std是命名空间（name space），将库定义的名字放在一个单一位置的机制
//命名空间可以避免不经意的名字定义冲突以及使用库中相同名字导致的冲突。
//标准库定义的所有名字都在命名空间std中
//当使用标准库中的名字时必须显示说明我们想使用来自命名空间std的名字，如std::cout

//::是作用域运算符，用来指出我们想使用定义在命名空间std中的名字cout
```

`endl`是被称为**操纵符（manipulator）**的特殊值，操纵符对象是用来操纵流本身的

写入endl的**效果是结束当前行并且换行，并且将与设备关联的缓冲区中的内容刷新到设备中。**

缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入输出流中，而不是仅停留在内存中等待写入输出流。

缓冲刷新可以强制将缓冲区中的数据写入输出设备

tips：一般调试时的打印操作都需要保证一直刷新流，否则程序崩溃，输出可能还留在缓冲区中，从而导致关于**程序崩溃位置**的错误判断。

因为如果程序崩溃，输出缓冲区不会被刷新



#### 从流读取数据

**输入运算符：`>>`**               **>>   operator**

它接收一个istream作为其左侧运算对象，它从给定的istream中读入数据存入其右侧给定的对象中。

**计算结果**与输出运算符类似，是其左侧运算对象。

`std::cin >> v1 >> v2;  //从std::cin读入两个值，第一个值存入v1，再将第二个值存入v2`

它与下面两条语句的执行结果相同：

```
std::cin >> v1;
std::cin >> v2;
```

#### 关于istream对象作为循环条件

`while(std::cin >> value)`

这里会检测流的状态，当流是有效的，即未遇到错误，那么检测成功。

当遇到EOF（end of file）文件结束符或无效输入时（例如读入的值类型和value不同），istream的状态会变为无效，即条件为假。

```c++
#include <iostream>

int main() {
    int sum=0,value;
    while(std::cin >> value){
        sum +=value;

    }
    std::cout << sum <<std::endl;
    return 0;
}
//输入：1 1 1 2.3 10
//结果为5    说明当输入类型不一致时，该值会先强转为int后仍然进入循环，下一次再停止循环

```

#### 键盘输入EOF：

Windows系统是ctrl + Z

UNIX中是ctrl + D

#### 缓冲区（buffer）刷新机制

缓冲区是一个存储区域，用于保存数据。IO设施通常将输入（或输出）数据保存在一个缓冲区中，读取缓冲区的动作与程序中的动作是无关的。我们可以显式地刷新输出缓冲，以便强制将缓冲区中的数据写入输出设备。

**缓冲区接到什么样信号才将其视为刷新信号呢？**

- **缓冲区已满**，需要刷新缓冲，而后新的数据才能继续写入缓冲区
- **执行flush、endl或ends等语句时**，假设你cout一段字符串，且字符串长度不至于过长，那么当你在每个字符串后不输入endl换行操作，而在全部字符串后输入时，你会发现，在终端上是没有任何的输出的，直到endl执行后，它会执行换行操作同时将缓冲队列内容强制输出并清除缓冲队列。其中，**flush刷新缓冲区，但不输出任何额外的字符；而ends向缓冲区插入一个空字符，然后刷新缓冲区**
- **程序正常结束时**，作为main函数的return操作的一部分，刷新缓冲区
- **通过unitbuf操纵符设置流的内部状态**，清空缓冲区。**默认情况下，对cerr是设置unitbuf的，因此写到cerr的内容都是立即刷新的**
- **一个输出流可能被关联到另一个流**，默认情况下cin和cerr都关联到cout，读cin或写cerr都会导致cout的缓冲区被刷新

**若程序崩溃，输出缓冲区不会被刷新**，输出的数据很可能停留在输出缓冲区中待打印。因此调试崩溃程序时需要将认为输出的数据确认刷新

```c++
cout << "hi" << endl;  //输出hi和一个换行，然后刷新
cout << "hi" << flush; //输出hi，然后刷新缓冲区，不附加任何额外字符
cout << "hi" << ends;  //输出hi和一个空字符，然后刷新

//unitbuf操纵符
cout << unitbuf; //所有输出操作之后都会立即刷新缓冲区
cout << nounitbuf; //回到正常的缓冲方式
```

**关联输入流和输出流**

当一个输入流被关联到一个输出流时，**任何从输入流读取数据的操作都会先刷新关联的输出流**

由于cout和cin默认关联在一起，因此读操作能刷新cout的缓冲区

**每个流最多同时关联到一个流，但多个流可以同时关联到ostream**

```c++
//tie不带参数返回指向本对象关联的输出流的指针，若本对象未关联到流，返回空指针
//tie带参，接收一个指向ostream的指针，将本对象关联到这个ostream，返回指向前一个绑定的流的指针，若没有返回空
cin.tie(&cout);
ostream *old_tie = cin.tie(nullptr);   //返回指向cout的指针
cin.tie(&cerr);
cin.tie(old_tie);

```




### 3、注释简介

注释可以帮助人类读者理解程序，编译器会忽略注释。

**单行注释**

以双斜线（//）开始，以换行符结束。当前行双斜线右边的所有内容都会被编译器忽略。

它可以包含任何文本，包括额外的双斜线

**界定符注释——多行注释**

以`/*`开始，以`*/`结束。它可以包含除了`*/`以外的任何内容，包括换行符

多行注释不能嵌套

当它跨越多行时，最好能显示指出其内部都是多行注释的一部分。风格是注释内每一行都以一个星号开头：

```
/*
*注释内容
*
*
*/
```

tips：在调试时我们会经常注释掉一些代码，由于其中可能包含界定符注释，因此可能会发生注释嵌套，最好的方法是使用单行注释

### 4、类简介

我们通过定义一个类（class）来定义自己的数据结构。类机制是C++最重要的特性之一，

每个类实际上都定义了一个新的类型，其类型名就是类名

类定义了行为，定义了类对象可执行的所有动作。



### 5、C++使用C语言的头文件

C++标准库中兼容了C语言的标准库，C语言头文件形如name.h

C++则将其命名为cname，也就是去掉了后缀.h，并且在name之前加上了字母c，表示属于C语言标准库的头文件

因此，比如`cctype`和`ctype.h`头文件的内容是一样的

**一般使用C++版本的标准库头文件**，cname头文件中定义的名字从属于命名空间std，而传统C语言方式的头文件.h则不是。如果使用传统形式，就不得不牢记哪些是C语言过来的，哪些是C++独有的



## 二、变量和基本类型

数据类型是程序的基础：它告诉我们数据的意义以及我们能在数据上执行的操作

数据类型决定了程序中数据和操作的意义

### 1、基本内置类型

C++定义了一套包括算术类型（arithmetic type）和空类型（void）在内的基本数据类型

算术类型包含字符、整型数、布尔值和浮点数

#### 算术类型

算术类型分为两类：[整型](https://so.csdn.net/so/search?q=整型&spm=1001.2101.3001.7020)(integral type,包含字符类型和布尔类型)和浮点型。

算术类型的尺寸在不同机器有所差别。

C++标准规定的尺寸**最小值**：允许编译器赋予它们更大的尺寸

| 类型        | 含义           | 最小尺寸（bit） | 字节（byte） |
| ----------- | -------------- | --------------- | ------------ |
| `bool`      | 布尔类型       | 未定义          |              |
| char        | 字符型         | 8位             | 1            |
| `wchar_t`   | 宽字符         | 16位            | 2            |
| `char16_t`  | Unicode 字符   | 16位            | 2            |
| `char32_t`  | Unicode 字符   | 32位            | 4            |
| short       | 短整型         | 16位            | 2            |
| int         | 整型           | 16位            | 2            |
| long        | 长整型         | 32位            | 4            |
| long long   | 长整型         | 64位            | 8            |
| float       | 单精度浮点数   | 6位有效数字     | 4            |
| double      | 双精度浮点数   | 10位有效数字    | 8            |
| long double | 扩展精度浮点数 | 10位有效数字    | 8            |

##### 字和字节

可寻址的最小内存块称为字节（byte）

存储的基本单元称为字（word），它通常由几个字节组成，一般是32或64位，即4或8字节。

**一般使用某个地址来表示从这个地址开始的大小不同的比特串。**

为了赋予内存中某个地址明确的含义，必须首先知道存储在该地址上数据的类型，类型决定了数据所占的比特数以及如何解释这些比特的内容。

通常，float以4个字节来表示，7个有效数字；double以8个字节来表示，16个有效数字；long double以12或16个字节来表示，被用于有特殊浮点需求的硬件，它的具体实现和精度各不相同

##### **带符号型和无符号型**

除去扩展的字符型和布尔型之外，其他整型可以化为**带符号的（signed）和无符号的（unsigned）**。

int、short、long、long和long long都是默认带符号的，char类型具体是哪一种取决于编译器。

##### 字面值常量（literal）

每个字面值常量都对应一种数据类型，它的形式和值决定了它的数据类型

指定字面值的类型：

| 前缀 | 含义                                                        | 类型       |
| ---- | ----------------------------------------------------------- | ---------- |
| u    | Unicode 16                                                  | `char16_t` |
| U    | Unicode 32                                                  | `char32_t` |
| L    | 宽字符                                                      | `wchar_t`  |
| u8   | UTF-8，用8位编码一个Unicode字符<br>**仅用于字符串字面常量** | char       |

##### 布尔字面值和指针字面值

布尔类型的字面值是true和false

​			`bool test = false;`

**`nullptr`是指针字面值**

### 2、变量（variable）

变量提供一个具名的，可供程序操作的存储空间。C++中每个变量都有其数据类型，数据类型决定着变量所占内存空间的大小和布局方式、该空间能存储值的范围，以及变量能参与的运算。

```c++
int sum = 0,value;
std::string book("三国演义");  //这里string代表可变长字符序列的数据类型
```

#### 何为对象（object）？

**对象是指一块能存储数据并具有某种类型的内存空间。（c++ primer所指的对象）**

一些人仅在与类有关的场景下才使用对象这个词。

另一些人则把已命名的对象和未命名的对象区分开来，将命名了的对象叫作变量。

还有人将对象和值区分开，其中对象指能被程序修改的数据，而值是只读的数据

#### 初始值

当对象在创建时获得了一个特定的值，我们说这个对象被初始化（initialized）了。

当一次定义了两个或多个变量时，对象的名字随着定义也就马上可以使用了。

```c++
//用先定义的变量值去初始化后定义的其他变量：
int price=100,discount=price*10;  //这里可以直接用之前定义的price的值
```

在C++中初始化和赋值是两个完全不同的操作！！！

初始化是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，以一个新的值来代替

#### 列表初始化

C++定义了多种不同的初始化形式：

```
int a=0;
int a={0};
int a{0};
int a(0);

int a{};   //花括号为空时会进行值初始化，这里会默认为0
```

**C++11中用花括号来初始化变量得到全面应用，这被称为列表初始化。**

**列表初始化作用于内置类型的变量时，若初始值存在丢失信息的风险，则编译器会报错：**

```c++
long double ld=3.1415926536;
int a{ld},b={ld};  //报错，存在丢失信息的风险，转换未执行
int c(ld),d=ld; //正确

```

#### 声明和定义

声明（declaration）使得名字为程序所知，一个文件想使用别处定义的名字则必须包含对那个名字的声明，此举是为了支持分离式编译。

定义负责创建与名字关联的实体

若想声明一个变量而非定义它，就在变量前添加**extern关键字**，而且不要显示地初始化它

任何包含了显示初始化的声明即成为定义。

```
extern int i;//声明
int j;//声明并且定义
extern int i=10; //定义
```

**注：在函数体内部不能初始化一个extern标记的变量！！！**

**变量能且只能被定义一次，但是可以被多次声明**

### 3、复合类型（compound type）

是指基于其他类型定义的类型，这里介绍两种：引用和指针

一条声明语句由一个基本数据类型和紧随其后的**声明符（declarator）**列表组成。之前接触的声明符就是变量名

#### 引用（reference）

引用变量**是一个别名**，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。

**引用的类型必须与其所引用对象的类型一致（有两个例外）**

**引用类型引用了另外一种类型。（比如int &b这里就是将b定义为一个对int类型数据的引用）**

对引用的操作与对原变量的直接操作效果完全一样，指向同一块内存。**引用即别名**

通过将声明符写成**&d**的形式来定义引用类型，其中**d是变量名**：

```c++
int ival=1024;
int &refVal=ival;  //refVal指向ival（相当于是ival的另一个名字）
int &refVal2;  //报错，引用必须被初始化
int &i=10;//报错，不能绑定字面值
int &refVal3=refVal;//正确  refVal3的值和refVal相同，均是对ival的引用

refVal=2; //相当于赋值给了ival
int i=refVal //与i=ival执行结果一样
```

在定义引用时，程序会把引用和它的初始值绑定（bind）在一起！！！**引用只能绑定在对象上，不能与字面值或表达式的计算结果绑定。**

声明引用时，必须同时对其初始化。不存在空引用！！！

引用声明一旦初始化，不能再将该引用名作为别的对象的别名。

**因为引用本身不是一个对象（不开辟内存空间，或者说它的内存空间只有编译器知道），所以不能定义引用的引用（不开辟空间即没有别名）**

```c++
int a=10;
int &&b=a； //会报错，这里b是引用，不能定义引用的引用。
```

#### 指针

在定义语句中，类型修饰符（&或*）并不是作用于本次定义的全部变量！！！

```c++
int* p1,p2; //注意：p1是指向int的指针，而p2是int类型！！！
```

**操作符***叫作**解引用符**，用于访问指向对象的值

**与引用类似，指针的类型必须与其所指对象的类型一致（有两个例外）**

##### 空指针（null pointer）

空指针不指向任何对象，在想要使用一个指针之前代码可以首先检查它是否为空

```c++
//以下效果相同：生成空指针
int *p=nullptr;  //nullptr是一种特殊类型的字面值，可以被转换成任意其他的指针类型
int *p=0;
//引入#include <cstdlib>
int *p=NULL;  //NULL是预处理变量，在cstdlib头文件中定义，它的值为0
```

预处理变量不属于命名空间std，它由预处理器负责管理，因此可以直接使用预处理变量而无须加上std::

最好使用`nullptr`，避免使用NULL。因为`nullptr`是有类型的，`nullptr_t`，而NULL的类型就是int。函数重载时NULL会有一些问题。

注：将int变量直接赋值给指针是错误的，即使他的值为0

```
int zero=0;
int *p=zero; //错误！！
```

##### 建议初始化所有指针

**任何非0指针对应的条件值都是true**

##### 指向指针的指针

一般声明符中修饰符的个数没有限制，有多个修饰符时按照其逻辑关系详加解释即可

指针也是内存中的对象，因此允许将指针的地址再存放到另一指针

通过*的个数可区分指针的级别：`**`代表指向指针的指针，**\*代表指向指向指针的指针的指针，以此类推。

```c++
int ival=1024;
int *pi=&ival; //pi指向int型的数
int **ppi=&pi; //ppi指向int型的指针

//为了ppi访问最原始的对象需要两次解引用
int a=**ppi;
```

##### 指向指针的引用

引用本身不是一个对象，因此不能定义指向引用的指针

但是指针是对象，所以存在对指针的引用：

```
int i = 42;
int *p;
int *&r = p; //r是一个对指针p的引用

r=&i;  //相当于令p指向i
*r=0;  //修改i的值为0
```

要理解r的类型到底是什么，最简单的办法是**从右向左阅读它的定义**。离变量名最近的符号对变量类型有最直接影响，因此r是一个引用。声明符的其余部分用来确定r引用的类型是什么。

### 4、const限定符

变量值不能被改变，定义为常量。

const对象一旦创建后其值就不能再改变，所以const对象必须初始化。

**默认状态下，const对象仅在文件内有效（即当前编译单元）**

编译器**会在编译过程中**把用到该变量的地方都替换成对应的值，因此编译器必须知道变量的初始值。

若有多个文件，则每个使用了const对象的文件都必须能访问到它的初始值，即每个文件中都必须进行定义，因此默认情况const对象仅在文件内有效。

多个文件中有同名的const变量时，其实相当于在不同文件中分别定义了独立的变量。

**文件之间共享const对象：**声明和定义都添加extern

```c++
//file.h头文件
extern const int;

//file.cpp
extern const int i=10;//在变量的定义之前加上extern才能在多个文件共享，但是全局变量默认是extern，则可不加
```

#### 对const的引用——常量引用

可以把引用绑定到const对象上，就像绑定到其他对象上，即**对常量的引用**。

对常量的引用不能被用作修改它所绑定的对象：

```c++
const int ci=1024;
const int &r1=ci; //正确：引用及其对应的对象都是常量，即ci的值不能修改

r1=42; //报错：常量不能修改
int &r2=ci; //报错：试图让一个非常量引用指向一个常量对象
```

#### 初始化常量引用

**引用的类型必须与其所引用对象的类型一致（有两个例外）**

第一种例外是**初始化常量引用时允许用任意表达式作为初始值（只要它的结果可以转换成引用的类型即可）**

常量引用绑定非常量的对象、字面量或表达式：

```c++
int i=42;	
const int &r1=i;		
const int &r2=42;	
const int &r3=r1*2;

int &r4=r1*2;  //报错:r4是一个普通引用，它不是常量引用


//常量引用相当于只读效果
int i=30;
const int &k=i;
i=10;
std::cout <<k; //此时结果会变为10，就是一个只读的效果

j=10; //报错： 不能通过常量引用修改
```

常量引用被绑定到另一种类型：

编译器会**将常量引用绑定一个临时量（temporary）对象**，所谓临时量对象就是当编译器需要一个空间来暂存表达式的结果时临时创建的一个未命名的对象，简称临时量。

举例说明：

```c++
double dval=3.14;
const int &ri=dval;  //dval可以转换为const int类型

//实际发生了如下操作：
const int temp=dval;//临时量
const int &ri=temp; //ri绑定了这个临时量

//改变dval的值：
dval=5.28;
std::cout <<ri;  //ri的值为3

```

**因此对const的引用即常量引用可能引用一个并非const的对象**



#### 指针和const

- 指向常量的指针：不能改变所指对象的值

  **指针的类型必须与其所指对象的类型一致（有两个例外）**

  第一种例外：允许指向常量的指针指向一个非常量对象：

  ```c++
  double dval=3.14;
  const double *cptr=&dval;
  
  
  const double pi=3.14;
  double *ptr=&pi; //报错：ptr只是一个普通指针
  ```

  其实指向常量的指针或引用只是它们的自以为是，它们觉得自己指向了常量，所以不能去改变所指对象的值

- const指针

  指针常量必须初始化，指针不能改变！！！

  ```c++
  const double pi=3.14;
  const double *const pip=&pi; //此时因为pip是指向常量的常量指针，他不能修改pi的值
  ```



#### 顶层const

用名词**顶层const**表示指针本身是个常量，而使用名词**底层const**表示指针所指的对象是一个常量

**更一般的，顶层const可以表示任意的对象是常量。**

而底层const则与指针和引用等复合类型相关，其中**引用都是底层const**

```
int i=10;
const int &r=i; //底层const，因为引用本身不是一个对象，更无法是常量
```

当执行对象的拷贝操作时：

顶层const不受影响；

底层const**必须有相同的底层const资格**或者**非常量可以转换成常量**，反之则不行！！！

```c++
int i = 0;
int *const p1=&i;
const int ci=42;
const int *p2=&ci;
const int *const p3=p2;
const int &r=ci;

//正确操作：
i=ci;  //ci是顶层const无影响
p2=p3; //p2和p3都是底层const
p2=&i //非常量i可以转为常量

//错误操作：
int *p=p3; //报错：p3包含底层const，p没有
int &r=ci; //报错：常量不能转化为非常量
```

#### constexpr和常量表达式

常量表达式（const expression）是指**值不会改变并且在编译过程中就能得到计算结果的表达式**

**字面值和用常量表达式初始化的const对象都是常量表达式**

数据类型和初始值共同决定一个对象（或表达式）是不是常量表达式：

```c++
//常量表达式：
const int max_files=20;
const int limit=max_files+1;

//不是常量表达式：
int size=27;//类型无const修饰
const int i=getSize(); //它的值需要运行时才能获取，因此也不是常量表达式
```

**constexpr变量**

一般很难分辨一个初始值是不是常量表达式

C++11中规定允许将变量**声明为constexpr类型**，以便由编译器验证变量的值是否是常量表达式

**声明为constexpr的变量一定是常量，并且必须用常量表达式初始化：**

```c++
constexpr int i=20;
constexpr int k=i+1;
constexpr int s=size(); //这里只有size是一个constexpr函数时才是一条正确的语句，不能是普通函数
//被定义成constexpr的函数应该足够简单使得编译时就能计算其结果
```

**声明constexpr必须要使用字面值类型**，即类型简单，值容易得到，包括算术类型、引用和指针。

自定义的类、IO库、string类型则不属于字面值类型，也就不能定义为constexpr

**constexpr指针的初始值必须是0或者是存储于某个固定地址中的对象（即全局变量或static修饰）**

**限定符constexpr仅对指针有效，即常量指针，与它所指的对象无关**

```c++
constexpr int *p=0; //p是指向int的常量指针，即指针不能改变

int i=0;constexpr int j=20; //i和j是全局变量
constexpr const int *p2=&j; //这里指向的对象也是常量
constexpr int *p3=&i;
```

### 5、类型的处理

#### 类型别名（type alias）

将复杂的类型名字变得简洁明了，便于理解和使用

有两种方法定义类型别名：

**关键字typedef**

```c++
typedef double wages;  //wages是double的别名
typedef wages base, *p; //base是double的别名，这里的p是double*的别名，因为*号理解成跟着double后面


//注意指针别名前加上const： 不是简单的文本替换！！！
typedef char *pstring; //pstring是char*的别名，代表的是指向char的指针
const pstring cstr=0; //这里const pstring就是指向char的常量指针，即指针本身不能改变，但是指向的值可以改变
const pstring *ps;//ps是一个指针，它的对象是指向char的常量指针
```

**别名声明（alias declaration，C++11新标准）**

使用using关键字作为别名声明的开始，其后紧跟别名和等号。

```c++
using SI = int; //SI是int的别名
```

#### auto类型说明符

编程时经常需要将表达式的值赋给变量，这要求声明变量时需要知道表达式的类型。然而做到这一点很难，C++11引入了auto类型说明符让编译器替我们分析表达式的类型

**auto让编译器通过初始值来推算变量的类型:auto定义的变量必须有初始值**

```c++
auto item = va1+va2; //auto定义的变量必须有初始值，item根据相加的结果推断出item的类型
//若它们相加的结果为double，则item的类型为double

//一条声明语句只能有一个基本数据类型：
auto i=0,*p=&i; //正确。。p是整型指针
auto sz=0,pi=3.14;//报错！！！sz和pi类型不一致

//使用引用其实是使用引用的对象：
int i=0,&r=i;
auto a=r;//a是一个整数
```

**注意：在C语言中auto 修饰的变量，是动态地分配存储空间，局部变量默认是auto**

**一般auto会忽略掉顶层const，保留底层const：**

```c++
	int i = 0;
    const int ci=10,&cr=ci;
    auto a = ci;  //int
    auto b = cr;  //int，cr只是别名
    auto d=&i;    //int *
    auto e=&ci;   //const int *

//保留顶层const的做法：
const auto f=ci; //这里的f就是const int

```

**类型为auto的引用中仍然会保留顶层const：**

```c++
//类型为auto的引用中仍然会保留顶层const：
auto &g=ci; //g是整型常量引用
auto &h=42; //报错：非常量引用不能绑定字面值
const auto &j=42; //正确：常量引用可以绑定字面值
```

#### decltype类型说明符

我们有时会希望从表达式的类型推断出要定义的变量类型，但是不想用该表达式的值初始化变量。

C++11引入了decltype( )，**它可以选择并返回操作数的数据类型。**

```c++
decltype(f()) sum =x; //sum的类型就是函数f的返回类型，编译器不实际调用函数f
```

**decltype返回变量的类型时包括顶层const和引用在内：**

```c++
const int ci=0,&cj=ci;
decltype(ci) x=0; //x类型是const int
decltype(cj) y=x; //y类型是const int &，需要绑定

decltype(cj) z; //错误：z是引用，必须初始化


//decltype返回表达式计算结果的类型
int i=42,*p=&i,&r=i;
decltype(r+0) b; // 正确：加法的结果是int
decltype(*p) c;  //报错：解引用符*会使decltype得到引用类型，这里是int &，则需要初始化
decltype((i)) d; //报错：d是引用类型int &，必须初始化
//变量加上括号后编译器会当成一个表达式,decltype((variable))双层括号的结果永远是引用！！！
```

**注：引用从来都是作为其所指对象的别名出现，只有用在decltype处是个例外！！**

## 三、字符串、向量和数组

### 1、命名空间的using声明（using declaration）

使用using声明就无须专门的前缀（命名空间：：）也能使用其中的名字

形式：

​		**`using namespace::name;`** 	//一旦声明该语句之后即可直接访问命名空间中的名字

```c++
#include <iostream>
using std::cin; //当使用cin时，从命名空间std来获取它

int main(){
	int i;
    cin >> i;
    std::cout << i;  //cout仍然需要显示声明命名空间
}
```

**注：每个名字都需要独立的using声明！！！**

**头文件不应包含using声明**

若头文件中有某个using声明，那么每个使用该头文件的文件就都会有这个声明。某些文件中不经意包含这些名字的话，可能发生冲突

### 2、标准库类型string

**标准库类型string表示可变长的字符序列，使用它必须包含string头文件：**

```c++
#include <string>
using std::string;
```

#### 定义和初始化string对象

如何初始化类的对象由类本身决定

```c++
string s1;   //默认初始化，s1是一个空字符串
string s2=s1;   //s2是s1的副本
string s3="hiya";   //s3是该字符串字面值的副本
string s4(10,'c');  //将s4初始化为连续10个‘c’组成的串，s4的内容是cccccccccc

string s2(s1); //等价于s2=s1
string s3("value"); //等价于s3="value"
```

#### 直接初始化和拷贝初始化

使用等于号`=`初始化一个变量，实际上执行的是拷贝初始化（copy initialization），编译器将等号右边的初始值拷贝到新创建的对象中去

如果不使用等于号，则执行的是直接初始化（direct initialization）

#### string对象上的操作

一个类需要定义对象上能执行的操作，包括函数名调用操作和各种运算符在该类对象上的新含义

![string对象的操作](D:\office\word\计算机基础\C++\截图\string对象的操作.jpg)

**getline读取一整行：**

可以保留输入时的空白符，它的参数是一个输入流和一个string对象，从给定的流中读入内容，直到遇到换行符为止（这里换行符也被读入了）。

然后将所读的内容存入到string对象中，这里换行符不保存，被丢弃了。最后返回参数输入流。

```c++
int main(){
	string line;
	while(getline(cin,line)){ //一次输入一整行，直到文件末尾或遇到非法输入
		cout << line <<endl;
	}
}
```



**string的empty和size函数**

```c++
//修改上面的程序只输出非空行：
while(getline(cin,line)){
    if(!line.empty()){
        cout << line << endl;
    }
   
}


//输出超过80个字符的行：
while(getline(cin,line)){
    if(line.size()>80){
        cout << line << endl;
    }
   
}
```

size函数返回的类型是`string::size_type`类型的值，表明它的名字size_type是在类string中定义的，**它是一个无符号类型的值并且足够存放任何string对象的大小。**

```c++
//存放size函数返回值的变量应该也是string::size_type类型
//C++11允许使用auto或者decltype来推断变量类型：
auto len = line.size();


注意如果使用一个int类型的负数n和s.size()比较大小，则s.size() < n的判断结果几乎肯定是true，因为负数n会自动转换成一个比较大的无符号数。
因此表达式中出现size()则不要使用int了，避免混用     
```

string类和其他大多数标准库类型都定义了几种配套类型，它们体现了标准库类型与机器相关的特性。



**关于+号运算符**

**标准库在运算时可以将字符字面值和字符串字面值自动转换成string对象（注意：字符串字面值并不是标准库中类型string的对象！！！它们是不同类型）**

**加号运算符两侧至少有一个是string对象！！！**

```c++
string sa="hello ",sb="world\n";
sa += sb;

string s1="hello" ,s2="world";
string s3= s1+","+s2+'\n';

string s4= "hello"+","; //报错:两个运算对象都不是string！！！

string s5= s1 + "," + "world"; //正确：第二个加号左侧会变成string对象
string s6="hello" + "," +"s2"; //报错：第一个加号两侧无string对象
```



#### 读写string对象

在执行读取操作时，**string对象会自动忽略开头的空白（空格、换行、制表符等）并从第一个真正的字符开始读起，直到遇到下一个空白为止**

例如输入“   hello   world!”，则输出的是hello，其中没有任何空格

```c++
int main(){
    string s;
    cin >> s;
    cout << s << endl;
    return 0;
}


int main(){
    string word;
    while(cin >> word){  //反复读取，直到文件末尾或遇到非法输入
        cout << word <<endl;
    }
}
```

#### 处理string对象中的字符

在cctype头文件中定义了一组标准库函数可以处理string对象中的字符：

![cctype中的函数](D:\office\word\计算机基础\C++\截图\cctype中的函数.jpg)

##### 范围for

C++11提供了**范围for（range for）语句：**

​				**遍历给定序列中的每个元素并对序列中的每个值执行某种操作**

范围for遍历的类型特点是拥有能返回迭代器的begin和end

```c++
for(declaration : expression)
	statement

expression是一个对象，表示一个序列。它可以是一条语句或一个块
declaration负责定义一个变量，用于访问序列中的基础元素。序列中的每个元素都得能转换成该变量的类型
每次迭代，该变量会被初始化为expression部分的下一个元素值

    
//这里通过auto让编译器决定变量c的类型，这里c的类型是char
string str("some string");  //string对象是一个字符序列
for(auto c:str)
    cout << c << endl;  //输出当前字符，并且换行


//统计string对象中标点符号的个数：
string s("hello world!!!");
decltype(s.size()) punct = 0;  //它的类型和s.size()一致！！！
for(auto c: s)
    if(ispunct(c))
        punct++;
cout << punct << "个标点符号" << endl;
```

**范围for语句修改字符串中的字符**

修改string对象的字符时，必须将循环遍历定义为引用类型，引用是给定对象的别名。

当引用作为循环变量时，它实际上被依次绑定到序列的每个元素上。使用这个引用就能修改它绑定的字符

```c++
string s("hello world");
for(auto &c : s)
    c=toupper(c);  //c是引用，因此最后s的值会改变
cout << s << endl;
```



**只处理string对象的部分字符**

**使用下标运算符[ ]，它接收的参数类型是string::size_type类型，返回值是该位置上字符的引用**

​		`s[0]`代表第一个字符，`s[s.size()-1]`代表最后一个字符

```c++
//访问字符之前需要检查是否为空
if(!s.empty())
	cout << s[0] << endl;


//将字符大写直到处理完全部字符或遇到空白
string s("hello world");
for(decltype(s.size()) index=0;index!=s.size()&&!isspace(s[index]);index++)
    s[index]=toupper(s[index]);
```

### 3、标准库类型vector（向量）

**标准库类型vector（向量）表示对象的集合，要求所有对象的类型相同**

集合中每个对象都有一个与之对应的索引，用于访问对象

vector容纳着其他对象，所以它也被叫作**容器（container）**

**头文件：**

```c++
#include <vector>
using std::vector;
```

C++语言既有类模板（class template），也有函数模板，其中**vector是一个类模板**

模板本身不是类或函数，可以将其看作是编译器生成类或函数编写的一份说明。**编译器根据模板创建类或函数的过程称为实例化（instantiation）**

当使用模板时，需要指出编译器应把类或函数实例化成何种类型。

**类模板需要使用`< >`这一对尖括号来指定模板到底实例化成什么样的类**

以vector为例，**vector< >尖括号中的信息代表vector中所存放对象的类型**

```c++
//vector< >尖括号中的信息代表vector中所存放对象的类型：

vector<int> ivec; //ivec保存int类型的对象
vector<vector<string>> file; //它的元素是vectro对象
```

**注：vector是模板，它不是一个类型，由vector生成的类型必须包含vector中元素的类型**

**由于引用不是对象，所以不存在包含引用的vector。其他大多数内置类型和类类型都可以构成vector对象，甚至组成vector的元素也是vector。**

早期的C++标准中如果vector的元素仍然是vector((或者是其他模板类型)，必须在外层vector对象的右侧尖括号和其元素类型之间添加一个空格：                                                                                                                                                                                                                                                                                                                                                                  

```
vector<vector<int> >; //注意空格
```

#### 定义和初始化vector对象                                                                                                                                    

![初始化vector对象](D:\office\word\计算机基础\C++\截图\初始化vector对象.jpg)

注：拷贝副本时两个vector对象对应的元素类型要相同！！！

可以默认初始化vector对象，从而创建一个指定类型的空vector：

```c++
vector<string> svec;//默认初始化，svec不含任何元素，是一个空vector
//我们可以高效地往vector对象中添加元素

vector<int> ivec; //初始为空
vector<int> ivec2(ivec); //把ivec的元素拷贝到ivec2

vector<string> svec(ivec2); //报错：svec的元素是string对象，不是int
```

大多数情况下初始化的方式可以等价使用，但也有例外情况：

##### 初始化的例外情况

1、拷贝初始化时（即使用`=`时）只能提供一个初始值

2、对于类内初始值的限制：只能使用花括号或者等号，不能使用圆括号！！！

3、如果提供的是初始元素值的列表，只能把初始值都放在花括号里进行列表初始化，不能放在圆括号中

```
//第3种情况的例外：
vector<string> v1{"a","an","the"};

vectro<string> v2("a","b");//错误！！！
```

##### 值初始化

通常我们可以只提供vector对象容纳的元素数量，此时库会创建一个值初始化的元素初值，并将它赋给容器中的所有元素

这个初值由vector对象中元素的类型决定，如果其中的元素是内置类型，**比如int，则自动设为0**

如果是某种类类型，比如string，则元素由类默认初始化。如果该类型不支持默认初始化，我们就必须提供初始值

```c++
vector<int> ivec(10); //10个元素默认初始化为0
vector<string> svec(10);    //10个元素默认都为空
```

##### 圆括号和花括号

圆括号提供的值是用来构造（construct）vector对象的

花括号即代表我们想列表初始化一个vector对象，即花括号中的值是元素初始值的列表（花括号的值必须与元素类型相同！！）

若使用花括号形式但是提供的值不能用来列表初始化，那么它就用来构造vector对象

```c++
vector<string> v{10}; //这里代表有10个默认初始化为空的元素

vector<string> v2{10,"hi"};  //这里代表有10个值为“hi”的元素

vector<string> v3{"hi"}; //列表初始化，只有一个元素

vector<string> v4("hi")  //报错：不能使用字符串字面值来构建vector对象
```

#### 向vector对象添加元素

push_back( )成员函数向vector对象末尾添加元素

```c++
vector<int> v; //空vector对象
for(int i=0;i!=100;i++){
    v.push_back(i);
}

string word;
vector<string> text;
while(cin >> word){
    text.push_back(word);
}
```

**vector对象能高效增长**，运行时可以高效快速地添加元素，定义时没必要设定大小，如果这样做了可能性能更差

如果循环体内部包含了向vector对象添加元素的语句，则不能使用范围for循环，**范围for语句中不应改变其所遍历序列的大小！！！**

![vector对象中的操作](D:\office\word\计算机基础\C++\截图\vector对象中的操作.jpg)

这里的size( )函数返回vector对象中元素的个数，返回值类型是由vector定义的size_type

**vector对象的类型总是包含着元素的类型：**

**vector内元素的索引类型是相应的size_type类型**

```c++
vector<int>::size_type //正确

vector::size_type   //错误！！！
    

//使用范围for处理vector中的元素    
vector<int> v{1,2,3,4,5,6,7,8,9};
for(auto &i:v)
    i *=i;
for(auto i:v)
    cout << i << " ";
cout << endl;
```

**只有当元素的值可比较时，vector对象才能被比较。**



##### 一个添加元素的错误

**不能用下标形式添加元素，正确的方法是使用push_back。**

**vector对象以及string对象的下标运算符可用于操作已存在的元素，而不能用于添加元素**

```
vector<int> ivec; //空vector对象
cout << ivec[0]; //错误：ivec不包含任何元素

vector<int> ivec2(10);
cout << ivec2[10]; //错误！合法索引是0-9
```

用下标去访问一个不存在的元素会引发不可知的错误，但是编译器不会发现。缓冲区溢出指的就是这类错误，这是导致PC及其他设备出现安全问题的一个重要原因

使用范围for是可以确保下标合法的有效手段

### 4、迭代器（iterator）介绍

我们可以使用下标运算符来访问string对象的字符或vector对象的元素，但是还有另一种更通用的机制可以实现同样的目的，即**迭代器**。迭代器可以间接访问容器中的对象

string严格来说不属于容器类型，但它支持很多和容器类型类似的操作

**所有的标准库容器都可以使用迭代器**，但只有少数几种才同时支持下标运算符

**迭代器的对象是容器中的元素或string对象中的字符，它可以访问某个元素或从一个元素移动到另外一个元素**

**有效的迭代器指向某个元素或指向容器中尾元素的下一个位置，其他所有情况都属于无效迭代器**

迭代器这个词有三种含义：

- 迭代器概念本身

- 容器定义的迭代器类型

- 某个迭代器对象

认定某类型是迭代器类型当且仅当它支持一套操作，这套操作可以让我们访问容器的元素或从某个元素移动到另一个元素

#### 使用迭代器

有迭代器的类型会同时拥有返回迭代器的成员，比如这些类型都拥有名为**begin**和**end**的成员

**begin返回指向第一个元素（或字符）的迭代器**

**end返回指向容器（或string对象）尾元素下一位置的迭代器，它只是个标记，无实际意义，也常被叫作尾后迭代器（off-the-end iterator）或尾迭代器(end iterator)**

当容器为空，begin和end返回的是同一个迭代器，这时他们都是尾后迭代器

```c++
//一般不清楚迭代器的准确类型
auto b =v.begin();
auto e =v.end();  //b和e的类型相同
```

##### 迭代器运算符

![迭代器运算符](D:\office\word\计算机基础\C++\截图\迭代器运算符.jpg)

**注：forward_list迭代器不支持递减运算符！！！**

**和指针类似，通过解引用符来获取迭代器指示的元素**

迭代器必须合法，**试图解引用尾后迭代器和非法迭代器都是未被定义的行为**

```c++
//使用迭代器将首字母改为大写：
string s("some string");
if(s.begin() != s.end()){   //可以确保s非空
	auto it = s.begin(); //it代表s的第一个字符
	*it = toupper(*it);  //将当前字符改成大写形式
}    

//第一个单词改为大写：
for(auto it=s.begin();it!=s.end()&&!isspace(*it);++it)
    *it = toupper(*it);
```

**end返回的迭代器并不实际指示某个元素，所以不能进行递增或解引用的操作**

##### string和vector迭代器支持更多的运算

- 可以加或减去一个整数值n，代表向前或后移动n个位置
- 两个迭代器相减，类似指针相减，结果是**地址差/sizeof(数据类型)**，即两个迭代器的距离。它的类型是**difference_type**的带符号整型数，可负可正，前提是地址连续
- 支持关系运算，位置上在前面的小于在后面的，前者小于后者

```c++
//迭代器的运算完成二分查找：从有序序列中寻找某个给定值
auto beg = text.begin(),end = text.end();  //text有序，是vector<string>
auto mid = text.begin() + (end-beg)/2;  //初始中间点

//若mid和end相等则代表找遍了所有元素则退出循环，sought为目标元素的值
while(mid != end&&*mid !=sought){
    if(sought<*mid)
        end=mid;
    else
        beg=mid+1;
    mid=beg+(end-beg)/2; //新的中间点
}


```



##### 泛型编程

C++在for循环习惯使用`!=`来进行判断，因为这种编程风格在标准库提供的所有容器上有效，所有容器的迭代器都定义了`==`和`!=`，但它们大多数并未定义`<`运算符。

使用了迭代器和`!=`，就不用在意到底是哪种容器类型

#### 迭代器类型

一般不知道（其实无需知道）迭代器的精确类型

**实际上，拥有迭代器的标准库类型使用`iterator和const_iterator`来表示迭代器的类型：**

**`const_iterator`能读取但不能修改它所指的元素值**

若容器对象或string对象是一个常量，则只能使用`const_iterator`

```c++
vector<int>::iterator it; //it能够读写vector<int>的元素
string::iterator it2; //it2能读写string对象中的字符

vector<int>::const_iterator it3;  //只能读元素，不能写
string::const_iterator it4;

```

begin和end返回的具体类型由对象是否是常量来决定，若是常量则返回`const_iterator`，不是常量则返回iterator

这种默认行为可能并非我们想要的，如果对象只需要读操作最好使用`const_iterator`

**C++11使用`cbegin`和`cend`来得到`const_iterator`类型**

```
auto it =v.cbegin();  //it的类型是const_iterator
```

#### 结合解引用和成员访问操作

解引用可获得迭代器所指的对象，若这个对象的类型是类，就可以进一步访问它的成员

对`vector<string>`来说，想检查元素是否为空字符串，令it是迭代器：

``` c++
(*it).empty();  //这里圆括号不能少
it->empty();  //和上面等价，箭头运算符将解引用和成员访问结合在一起 
```

#### 迭代器失效

- 不能在范围for中向vector对象添加元素

- 任何一种可能改变vector对象容量的操作都会使该vector对象的迭代器失效

- 只要是使用了迭代器的循环体，都不要向迭代器所属的容器添加元素

### 5、数组

**数组也是存放类型相同的对象的容器，大小固定不变，不能随意向数组中增加元素**

`a[d]`这里的d代表数组的维度，即元素的个数

**编译时维度必须已知，因此它必须是一个常量表达式**

**不允许使用auto关键字由初始值的列表来推断类型，定义数组必须指定数组的类型**

**不存在引用的数组，数组的元素应为对象，和vector相同**

```c++
//关于初始化
const unsigned sz=3;
int a1[sz]={0,1,2};
int a2[5]={0,1,2};  //剩余元素默认为0

int scores[10]={};  //这里全部会初始化为0，发生值初始化

string a3[3]={"hi","bye"}; //剩余元素为空字符

int a4[2]={0,1,2}; //错误：初始值太多
```

#### 复杂的数组声明

默认情况下类型修饰符从右向左依次绑定，数组的维度是紧跟着被声明的名字的

加上括号则需要由内向外看

```c++
//含有10个整型指针的数组
int *ptrs[10];  

int arr[10];
//*parrar代表着parray是个指针，指向一个含有10个整数的数组
int (*parray)[10] = &arr;
//同理，arrRef是引用，它引用的对象是一个大小为10的整数类型的数组
int (&arrRef)[10] = arr;

//arry是一个引用，它引用的对象是一个大小为10的数组，数组的类型是指向int的指针
int *(&arry)[10] = ptrs;

 
//错误！！！不存在引用的数组
int &refs[10];

```

**注：使用引用时数组名不会自动转化为指针，而是数组类型**

C语言标准规定，当数组名作为数组定义的标识符（也就是定义或声明数组时）、**sizeof 或 & 的操作数时，它才表示整个数组本身**，在其他的表达式中，数组名会被转换为指向第 0 个元素的指针

#### 访问数组元素

**范围for或者下标运算符**

数组下标一般是**size_t类型**，是一种机器相关的无符号类型，它足够大，可以表示内存中任意对象的大小。**头文件`cstddef`中定义了该类型，即C语言的`stddef.h`**

程序员必须检查数组的下标是否越界，这点和vector和string一样。

大多数的安全问题都源于缓冲区溢出错误，当下标越界时就会发生类似的错误

```c++
//统计各个分数段的成绩
unsigned scores[11]={};  //这里全部会初始化为0
unsigned grade;
while(cin >> grade){
    if(grade<=100)
        scores[grade/10]++;
}

//范围for输出结果
for(auto i:scores)
    cout << i <<" ";
cout << endl;
```

#### 指针也是迭代器

**auto和decltype的使用**

```c++
int ia[]={0,1,2,3,4,5,6,7,8,9};
auto ia2(ia);  //ia2是指针类型

//这里不会将数组名转换成指针，返回的类型是由10个整数构成的数组
decltype(ia) ia3={0,2,3,4,5,6,1,7,8,9};  
ia3[4]=12;
```

**获取数组的尾后指针：**

尾后指针不指向具体元素，不能对其执行解引用或递增的操作

```c++
int arr[] ={0,1,2,3,4,5,6,7,8,9};
//指向尾元素的下一位置的指针，紧跟着尾元素的下一个索引来获得
int *e = &arr[10];

for(int *b=arr;b!=e;b++){
    cout << *b << endl;
}
```

**C++11提供了begin和end函数来获取首指针和尾后指针，定义在iterator头文件中，类似于容器中同名的成员函数。**

**由于数组不是类类型，可以将数组作为他们的参数。**

begin函数返回首元素的指针，end返回尾元素下一个位置的指针

```c++
int ia[]={0,1,2,3,4,5,6,7,8,9};
int *beg = begin(ia);
int *last = end(ia);
```

**两个指针相减的结果是他们之间的距离，类型是`ptrdiff_t`的标准库类型，定义在`cstddef`头文件中。它是带符号类型**



#### 下标和指针

对数组执行下标运算其实是对指向数组元素的指针执行下标运算

```c++
int *p = &ia[2];

//p[1]相当于*（p+1）,即代表ia[3]
int j = p[1];

//p[-2]代表ia[0]，相当于*(p-2)
int k = p[-2];
```

**标准库类型中下标必须是无符号类型，而内置类型的下标运算不一定**



#### string对象和C风格字符串混用

任何出现字符串字面值的地方**都可以用空字符结束的字符数组来替代：**

- 它可以初始化string对象或者为它赋值

- string对象的加法运算可以使用它可以作为一个运算对象（不能两个都是），也可以作为复合赋值运算中的右侧运算对象

**string对象无法直接代替C风格字符串**

`c_str`函数返回一个C风格的字符串，返回一个指针，它指向一个以空字符结束的字符数组，类型是`const char*`，确保我们不会修改其中的内容

```c++
string s("hello world");
char *str = s; //错误：不能用string对象初始化char*

const char *str = s.c_str(); //正确
```

如果后续操作修改了s的值就可能会让之前返回的数组失效

如果想一直使用`c_str`函数返回的数组，最好将这个数组拷贝一份

#### 数组初始化vector对象

不能用数组为另一个数组赋初值，也不允许使用vector对象来初始化数组

可以使用数组来初始化vector对象，**只需指明要拷贝区域的首元素地址和尾后地址**

```c++
int arr[]={0,1,2,3,4};
vector<int> ivec(begin(arr),end(arr));

//用于初始化vector对象的值可能只是数组的一部分，注意第二个是尾后地址
vector<int> subVec(arr+1,arr+4);  //即三个元素，arr[1]  arr[2]  arr[3]
```

我们尽量使用标准库类型而非数组或C风格的字符串

### 6、多维数组

严格来说C++中没有多维数组，一般多维数组是指数组的数组

一般用两个维度来定义：一个维度表示数组本身大小，另一个表示其元素（也是数组）的大小

二维数组第一个维度常叫作行，第二个叫作列

```c++
int ia[3][4]; //大小为3的数组，每个元素是含有4个整数的数组

//大小为10的数组，它的每个元素是大小为20的数组，这些数组的元素是含有30个整数的数组
int arr[10][20][30]={0};  //所有元素初始化为0
```

#### 多维数组的初始化

```c++
int ia[3][4]={
    {0,1,2,3},
    {4,5,6,7},
    {8,9,10,11}
};

//上面内嵌的花括号不是必需的
int ia[3][4]={0,1,2,3,4,5,6,7,8,9,10,11};


//仅仅初始化每一行的第一个元素，其余元素默认初始化为0
int ia[3][4]={{0},{4},{8}};

//省略内层花括号,这里代表初始化第一行了
int ia[3][4]={0,3,6,9}; 
```

#### 多维数组的下标引用

- 如果表达式含有的下标运算符数量和数组维数一样多，则该表达式的结果是给定类型的元素

- 如果表达式中下标运算符数量比数组的维度小，则表达式结果是给定索引处的一个内层数组

```c++
//ia[2]得到数组ia最后一行，返回的是最后一行的这个一维数组,再取下标ia[2][3]得到最后一行编号为3的元素
ia[2][3] = arr[0][0][0];  //等号右边同理


//将row引用绑定到ia第二个数组上，ia中每个元素都是大小为4的数组
int (&row)[4] = ia[1];
```

#### 范围for处理多维数组

```c++
constexpr size_t rowCnt=3,colCnt=4;
int ia[rowCnt][colCnt];
size_t cnt=0;
for(auto &row : ia)  //需要改变元素的值，所以将row和col声明成引用类型
    for(auto &col : row){
        col = cnt;
        cnt++;
    }


//外层的引用是为了避免数组名被自动当做指向首元素的指针，当成指针后内层循环就不合法，会在一个int *内遍历
for(const auto &row : ia)
    for(auto col :row)
        cout << col << endl;
```

**注：范围for处理多维数组，除了最内层循环外，其他所有循环的控制变量都要是引用类型**

#### 指针和多维数组

使用多维数组的名字时，也会自动将其转换为指向数组首元素的指针，即**第一个内层数组的指针**

```c++
int ia[3][4];   //大小为3的数组，每个元素是含有4个整数的指针
int (*p)[4] = ia;  //p是指针，指向含有4个整数的数组
p = &ia[2];  //p是指针，指向了ia中的第三个内层数组


//p是指针，指向了含有4个整数的数组
for(auto p = ia; p != ia+3; p++){
    //*p代表了含有4个整数的数组，它就相当于是数组名，会自动转换为指针，因此q是一个指针
    for(auto q=*p; q!=*p+4; q++){
        cout << *q << ' ';
    }
    cout << endl;
}

//使用begin和end
for(auto p=begin(ia); p !=end(ia); p++){
    for(auto q=begin(*p); q !=end(*p); q++){
        cout << *q << ' ';
    }
    cout << endl;
}

```

#### 类型别名简化多维数组的指针

```c++
//使用类型别名简化多维数组的指针
using int_array = int[4];  //代表4个整数组成的数组
typedef int int_array[4];  //和上面的一行等价

for(int_array *p =ia; p!=ia+3; p++){
    for(int *q =*p; q!=*p+4; q++){
        cout << *q << ' ';
    }
    cout << endl;
}
```

## 四、表达式和语句

**表达式由一个或多个运算对象（operand）组成，对表达式求值将得到一个结果。**

字面值和变量是最简单的表达式，它们的结果就是字面值和变量的值

### 1、基础

**关于取模**

**取模运算结果的正负是由左操作数的正负决定的。如果%左操作数是正数，那么取模运算的结果是非负数；如果%左操作数是负数，那么取模运算的结果是负数或0。**

#### **重载运算符**

当运算符作用于类类型的运算对象时，用户可以自定义它的含义。这种自定义的过程事实上是为已经存在的运算符赋予了另一层含义，即**重载运算符（overloaded operator）**

IO库中的<<和>>运算符、string和vector对象中的运算符都是重载运算符

**重载运算符可以定义运算对象的类型和返回值的类型，但是运算对象的个数和运算符的优先级、结合律都无法改变**

#### 左值和右值

**C++的表达式要么是右值，要么是左值。**

C语言中的左值位于赋值语句的左侧，右值则不行。C++中二者的区别更为复杂

**左值表达式的求值结果是一个对象或一个函数**，但是常量对象为代表的某些左值实际上不能作为赋值语句的左侧运算对象。

此外，某些表达式求值结果是对象，但它们是右值。

**当一个对象被用作右值时，用的是对象的值（内容）。当对象被用作左值时，用的是对象的地址（在内存中的位置）**

不同的运算符对运算对象的要求各不相同，它们需要左值或右值运算对象，它们的返回值也是左值或右值结果

**！！！重要原则：可以使用左值来代替右值，但不能将右值当成左值来使用**

左值被当作右值时，实际使用的是它的内容（值）

##### **常见的运算符说明：**

- **赋值运算符**需要一个非常量左值作为左侧运算对象，得到的结果也是一个左值（注：初始化不是赋值）

- **取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值**

- **解引用运算符、下标运算符的求值结果都是左值**

- **递增递减运算符**作用于左值运算对象，前置则将对象本身作为左值返回；后置则将对象原始值的副本作为右值返回

  **注：除非必要，后置版本一般不使用。后置需要先将原始值存储下来并返回，如果不需要修改前的原始值，后置操作就是一种浪费。对于一些复杂的迭代器类型，这种额外工作消耗太大**

- **算术、关系、逻辑运算符**的运算对象和求值结果都是右值

- **箭头运算符**作用于一个指针类型的运算对象，结果是左值

- **点运算符**如果成员所属的对象是左值，那么结果是左值；反之，成员所属的对象是右值，那么结果是右值

- **条件运算符（？:）**的两个表达式都是左值或者能转换成同一左值类型时，结果是左值；否则是右值

##### **关于`decltype`的使用**

`decltype`在使用时，**其中表达式结果是左值，则得到一个引用类型**

假如`p`的类型是`int *`，解引用运算符生成左值，则`decltype(*p)`的结果是`int &`

取地址运算符生成右值，`decltype(&p)`的结果是`int **`，是一个指向整型指针的指针



#### **求值顺序**

在大多数情况下，不会明确指定求值的顺序

```
int i = f1()*f2();
```

比如上述表达式中，f1和f2会在乘法之前先被调用，相乘的是他们的返回值，但是**我们无法知道它们哪个会先被调用**

**没有指定求值顺序，如果表达式指向并修改了同一对象，会引发错误并产生未定义的行为**

```
int i = 0;
cout << i << ' ' << ++i;   //<<没有明确规定求值顺序，这里编译器可能先求i，也可能先求++i
```

**4种明确规定求值顺序的运算符：**

&&和||，先求左侧运算对象的值。		条件（三目）运算符		逗号运算符

**注：求值顺序与优先级、结合律无关**

```
f() + g()*h() + j()
```

上述式子中优先级规定g和h的返回值先相乘

结合律是左结合律，规定从左到右依次运算，f的返回值加上g和h的乘积，再加上j的返回值

求值顺序则是哪一个函数先被调用无法知道

### 2、成员访问运算符

点运算符和箭头运算符都可以用于访问成员

点运算符获取类对象的一个成员，箭头运算符与点运算符有关

`ptr -> mem 就等价于(*ptr).mem`

```c++
string s1 = "a string",*p = &s1;
auto n = s1.size();
n = (*p).size();  //运行p所指对象的size成员
n = p -> size();  //和上一行等价

//顺便提一下，这里等价于*(ptr++)
*ptr++; 
```

**注：点运算符优先级高于解引用运算符**

**后置递增运算符的优先级高于解引用运算符**

### 3、条件运算符

`cond ? expr1 : expr2;`

`expr1和expr2`是两个类型相同或可能转换为某个公共类型的表达式

#### 嵌套条件运算符

条件表达式可以作为另一个条件运算符的`cond或expr`

```c++
finalgrade = (grade > 90) ? "high pass"
    					  : (grade < 60) ? "fail" : "pass";
```

条件运算符满足右结合律，即运算对象从右向左组合。右边的条件运算构成左边的分支

第一个条件检查成绩是否在90以上，如果是则得到“high pass”，否则执行分支。这个分支会检查成绩是否在60以下，如果是则得到“fail"，否则得到"pass"。

#### 在输出表达式中使用条件运算符

条件运算符的优先级很低，因此一般需要加括号

```
cout << ((grade < 60) ? "fail" : "pass");
```



### 4、位运算符

位运算符作用于整数类型的运算对象

一种名为`bitset`的标准库类型也可以表示任意大小的二进制位集合，所以位运算也可以用于`bitset类型`

一般运算对象是小整型，值会被自动提升为较大的整型（自动类型转换）

如果运算对象是负数，那么位运算符如何处理符号位依赖于机器。此时左移操作可能改变符号位的值，是未定义行为

**建议位运算符用于无符号类型**

**移位运算符（>>和<<）**中右侧运算对象一定不能为负，而且值必须严格小于结果的位数，否则会产生未定义的行为。移出边界之外的位就会舍弃

移位运算符满足左结合律。它的优先级介于中间，**比算术运算符低，比关系运算符高**

### 5、sizeof运算符

它返回一条表达式或一个类型名字所占的字节数，满足右结合律，返回值是size_t类型的常量表达式

`sizeof`**并不实际计算其运算对象的值**，因此下面的`sizeof *p`中即使p是无效（未初始化）的指针，也没影响

```c++
//两种形式：
sizeof(type);
sizeof expr;  //返回的是表达式结果类型的大小

int data ,*p;
sizeof(int);
sizeof data;  //data类型的大小，即和上一行一样

sizeof p; //指针本身所占的大小
sizeof *p;  //p所指向类型的大小，即相当于sizeof(int)，sizeof优先级和*一样，也相当于sizeof (*p)
```

C++11允许使用作用域运算符来获取类成员的大小

通常只有类对象才能访问类成员，但是sizeof运算符无须我们提供具体的对象

```c++
Sales_data data;
sizeof Sales_data::revenue; //revenue成员对应类型的大小
sizeof data.revenue; //和上一行等价
```

**对引用类型执行sizeof运算得到被引用对象所占空间的大小**

**对数组执行sizeof得到整个数组所占空间的大小（sizeof运算不会将数组当成指针来处理），它的返回值是常量表达式，可以用`sizeof(a)/sizeof(*a)`的结果声明数组的维度**

**对string对象或vector对象执行sizeof只会返回该类型固定部分的大小，不会计算对象中的元素总共占用多少空间**

### 6、逗号运算符

它含有两个运算对象，按照从左到右的顺序依次求值。首先对左侧的表达式求值，然后丢弃结果。逗号运算符真正的结果是右侧表达式的值。

如果右侧运算对象是左值，那么最终的结果也是左值

逗号运算符常用于for循环

### 7、类型转换

如果两种类型可以相互转换，则它们就是关联的

#### 隐式（自动）类型转换（implicit conversion）

算术类型之间的隐式转换被设计得尽可能避免损失精度

**以下情况编译器会自动转换运算对象的类型：**

- 大多数表达式中比int类型小的整型值首先提升为较大的整数类型

- 在条件中，非布尔值转换为布尔类型
- 初始化时，初始值转换为变量的类型。在赋值语句中，右侧运算对象转换成左侧运算对象的类型
- 算术运算或关系运算的运算对象需要转成同一类型
- 函数调用时也会发生类型转换

##### 无符号类型的运算对象

带符号类型大于无符号类型，此时转换的结果依赖于机器：

**如果无符号类型的所有值都能存在于这个带符号类型中，则无符号类型的运算对象转换成带符号类型。如果不能，那么带符号类型的运算对象转换成无符号类型**

比如long和unsigned int，机器中int和long大小相同，此时long不能存放unsigned int的所有值，则long类型转换成unsigned int。如果long类型比int大，则unsigned int转换为long

##### 数组转换成指针

大多数情况下数组自动转换成指向首元素的指针

**当数组被用作`decltype`关键字的参数、作为取地址（&）、sizeof和typeid等运算符的运算对象时，则不会转换**

##### 类类型定义的转换

类类型能定义由编译器自动执行的转换，编译器每次只能执行一种类类型的转换



#### 显式类型转换

可以叫作**强制类型转换（cast）**

一个命名的强制类型转换形式如下：

​				`cast-name<type>(expression)`

- type是转换的目标类型，expression是要转换的值。若type是引用类型，则结果是左值
- cast-name指定了执行哪一种转换，是**`static_cast、dynamic_cast、const_cast和reinterpret_cast`**的一种

**`static_cast`**

任何具有明确定义的类型转换，只要不包括底层const，都可以使用static_cast

适用于需要把一个较大的算术类型赋值给较小的类型、编译器无法自动执行的类型转换

```c++
void *p = &d;
double *dp = static_cast<double*>(p);
```

**`const_cast`**

**它只能改变运算对象的底层const**。只有它能改变表达式的常量属性，但它不能改变表达式类型

将常量对象转换成非常量对象的行为即去掉const性质，编译器此时允许对该对象进行写操作

**适用于有函数重载的上下文中，其他情况不建议使用**

```c++
const char *pc;
char *p = const_cast<char*>(pc);
```

上述代码中如果pc指针指向的对象本身不是常量，那么强转后可以进行写操作；

如果它指向的对象是常量，那么强转后会产生未定义后果

**`reinterpret_cast`**

通常为运算对象的位模式提供较低层次上的重新解释，使用它是非常危险的

```c++
int *ip;
char *pc = reinterpret_cast<char*>(ip); //实际没什么意义，pc所指的真实对象是int
```

上述代码中类型改变了，但编译器没有任何警告或错误提示

编译器会认定`pc`的值是char *类型，但不知道它实际存放的是指向int的指针。

### 8、运算符优先级表

由高到低：

![运算符优先级](D:\office\word\计算机基础\C++\截图\运算符优先级.jpg)

![运算符优先级2](D:\office\word\计算机基础\C++\截图\运算符优先级2.jpg)

### 9、try语句块和异常处理

**异常是指在运行时的反常行为。**

程序某部分检测出问                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            题时应该发出某种信号来表明程序发生了故障，信号的发出方不需要知道故障在何处解决

如果发生了异常并且没有处理，系统会调用**terminate函数并终止当前程序的执行**

C++中异常处理包括：

- **throw表达式**		异常检测部分用它表示遇到无法处理的问题，throw引发了（raise）异常
- **try语句块**              异常处理部分使用它来处理异常。它以try开始，并且以一个或多个catch字句结束。**在try语句块中代码抛出的异常会被某个catch字句处理**
- **一套异常类**            用于在throw和相关的catch子句之间传递具体的异常信息

#### throw表达式

throw后面紧随一个表达式，这个表达式的类型就是抛出的异常类型

```c++
//检查两个数据是否是同一种书籍
if(item.isbn() != item2.isbn())
    throw runtime_error("data must refer to same ISBN"); //抛出异常会终止运行
cout << item1 + item2 << endl;
```

上述代码异常类型是runtime_error，是一种标准库异常类型，定义在`stdexcept`头文件中。必须使用字符串对它初始化

#### try语句块

```c++
try{
	//...
} catch (exception-declaration){  //括号内是异常声明
	//...
} catch (exception-declaration){
	//...
} //...



try{
    //抛出一个runtime_error异常
} catch (runtime_error err){
    //进行相对应处理
    cout << err.what() << endl;
}
```

每个标准库异常类都定义了what这个成员函数，它们没有参数，返回值是指向C风格字符串的`const char*`。**如果异常类型有一个字符串初始值，则what返回该字符串。若没有，返回内容由编译器决定**

在异常发生期间正确执行了清理工作的程序叫作**异常安全代码**

#### 标准异常

标准库定义了一组类，用于报告标准库函数遇到的问题。它们定义在4个头文件中

- exception头文件定义了最通用的异常类exception，只报告异常的发生，不提供额外信息
- `stdexcept`头文件定义了几种常用的异常类
- new头文件定义了`bad_alloc`异常类型
- type_info头文件定义了bad_cast异常类型

![stdexcept中的异常类](D:\office\word\计算机基础\C++\截图\stdexcept中的异常类.jpg)

**exception、`bad_alloc`、bad_cast的对象只能用默认初始化的方式**

**其他异常类型需要使用string对象或C风格字符串初始化，不允许默认初始化**

## 五、函数

调用运算符（call operator）来执行函数，它是一对圆括号，作用于一个表达式，**这个表达式是函数或指向函数的指针**

**实参是形参的初始值，实参的类型必须与对应的形参类型匹配（其实就是初始化，可以包括一些自动类型转换）**

**函数的返回类型不能是数组或函数，但是可以是指向数组或函数的指针**

局部静态变量会执行值初始化，内置类型的局部静态变量初始化为0

### 1、函数传参

#### 引用传参

形参是引用类型，他会绑定到对应的实参上

```c++
void reset(int &i){
	i = 0;
}

int main(){
	int j = 42;
	reset(j);  //j会变为0
}
```

#### 数组引用形参

引用绑定到对应的实参上，这里即绑定到数组

```c++
void print(int (&arr)[10]){  //此时只能传递大小为10的数组
	for(auto elem:arr)
        cout << elem << endl;
}
```

#### 传递多维数组

将多维数组传递给函数时，真正传递的是指向多维数组中首个内层数组的指针

数组第二维（包括之后的维度）的大小都是数组类型的一部分，不能省略

```c++
//第一个参数指向含有10个整数的数组的指针
void print(int matrix[][10],int rowSize){  //和一维数组一样，编译器会忽略第一个维度
	//...
}

//等价形式
void print(int (*matrix)[10],int rowSize){
    //...
}
```

#### 含有可变形参的函数

有时无法预知应该向函数传递几个实参

- 如果所有**实参类型相同**，可以传递一个叫做**initializer_list的标准库类型**

- 如果**实参类型不同**，可以编写一种特殊的函数，即可变参数模板

有一种特殊的形参类型（省略符），可以用它传递可变数量的实参。它一般只用于和C函数交互的接口

##### initializer_list形参

适用于实参数量未知但是类型相同

它是一种模板类型，它对象中的元素永远是**常量值，无法修改**

![initialiezer_list上的操作](D:\office\word\计算机基础\C++\截图\initialiezer_list上的操作.jpg)

```c++
//作为可变数量的形参
void error_msg(initializer_list<string> il){
    for(auto beg = il.begin();beg != il.end();++beg)
        cout << *beg << " ";
    cout << endl;
}

//需要使用花括号向其中传入序列
error_msg({"function","ok"});
```

##### 省略符形参

便于访问C代码而设置，使用了`varargs`这一C标准库功能。省略符形参仅用于C和C++通用的类型。大多数类类型的对象在传递给省略符形参时无法正确拷贝

**省略符形参只能出现在形参列表的最后一个位置，它对应的实参不需要类型检查**

```c++
void foo(parm_list,...); 
void foo(...);
```

### 2、返回值

return语句返回值的类型必须与函数的返回类型相同，或者可以隐式转换

返回一个值的方式和初始化变量一样，**返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果**

不能返回局部对象的引用或指针

```c++
const string &manip(){
	string ret;
    if(!ret.empty())
        return ret;    //错误！！！不能返回局部对象的引用
    else
        return "empty";  //错误！！字符串字面值会转换成局部临时string对象，也是局部的
}
```

**调用一个返回引用的函数得到左值，其他返回类型得到右值**

**C++11规定函数可以返回花括号包围的值的列表，如果列表为空，则执行值初始化**

```c++
vector<string> process(){
    //这里假设expected和actual是string对象
    if(expected.empty())
        return {};
    else if(expected == actual)
        return {"function","ok"};
    else 
        return {"function","aaaa"};
}
```

如果返回的是内置类型，则花括号中最多包含一个值

在主函数main中，结尾处编译器会隐式地插入一条`return 0;`

main函数不能调用它自己

#### 返回数组指针

**数组的维度必须跟在函数名字之后，但是形参列表应该先于数组的维度**

​			`type (*function(parameter_list))[dimension]`

type即元素类型，dimension是数组的大小

注意：`(*function(parameter_list))`两端括号必须存在！！！

```c++
int (*func(int i))[10];

//C++11可以使用尾置返回类型，适用于复杂的返回类型
auto func(int i) -> int(*)[10];
```

##### 可以使用类型别名

```c++
typedef int arrT[10];
using arrT = int[10];  //两条语句等价，代表含有10个整数的数组

arrT* func(int i);
```

##### 使用decltype

已知函数返回的指针将指向哪个数组时可以使用

```c++
int odd[] = {1,3,5,7,9};
int even[] = {0,2,4,6,8};

decltype(odd) *arrPtr(int i){  //decltype的结果是数组
    return (i%2) ? &odd : &even;  //这里需要加&，代表是数组的地址
}
```

### 3、函数重载

**同一作用域中几个函数的名字相同但是形参列表不同，我们叫作重载（overloaded）函数。可以用于相似的操作，减轻记忆名字的负担**

编译器会根据传递的实参类型推断想要的是哪个函数。**重载函数应该在形参数量或类型上有所不同，不能出现只有返回类型不同，其他所有要素相同的情况！！**

注：main函数不能重载

#### 判断两个形参的类型是否相异

```c++
int lookup(const int &acct);
int lookup(const int&);   //这是同一个函数，形参名不影响

typedef int are;
int lookup(const are&);  //仍然是和上面同一个函数，are只是int的别名
```

顶层const不影响传入函数的对象，顶层const形参无法和没有顶层const的形参区分，因此它们等价

由于也可以将非常量赋值给const限定的对象，**此时编译器会优先选用非常量版本的函数**

```c++
int lookup(int i);
int lookup(const int i); //重复声明，不是重载

int lookup(int *p);
int lookup(int * const p); //重复声明，不是重载

int lookup(int &p);
int lookup(const int &p); //新函数，这里是底层const，属于重载
```

#### `const_cast`和重载

```c++
//返回const引用
const string &shorterString(const string &s1,const string &s2){
    return s1.size() <= s2.size() ? s1 : s2;
}


//利用重载返回普通的引用，它内部调用了const的版本
string &shorterString(string &s1,string &s2){ 
    //这个引用绑定在了非常量实参上
    auto &r = shorterString(const_cast<const string&>(s1),const_cast<const string&>(s2));
    return const_cast<string&>(r); //安全的返回普通的string&
}
```

### 4、特殊用途语言特性

#### 默认实参（default argument）

**函数声明中可以为一个或多个形参定义默认值，但它必须出现在形参列表最后**

局部变量不能作为默认实参

如果想使用默认实参，只要在调用函数时省略该实参即可

```c++
int func(int a,int b=0,int c=1);

//调用
func(5); //等价于func(5,0,1)
func(5,10); //等价于func(5,10,1)
```

一般一个函数只声明一次，多次声明同一个函数也是合法的，**但是同一作用域一个形参只能被赋予一次默认实参**

```c++
string screen(int,int,char = ' ');
string screen(int,int,char='*'); //错误！！！ 不能修改默认值
string screen(int = 1,int =2,char = ' '); //正确
```

#### 内联函数和constexpr函数

##### **内联函数**

调用函数一般比求等价表达式的值要慢一些

**内联函数（inline）可以避免函数调用的开销，通常就是将它在每个调用点上内联地展开**

```c++
cout << shorterString(s1,s2) << endl;
比如说上面的这个调用会在编译过程中展开成类似于下面的形式：
cout << (s1.size() < s2.size() ? s1 :s2) <<endl; //消除函数的运行时开销


//声明内联函数：返回类型前面加上inline
inline const string &shorterString(const string &s1,const string &s2){
    return s1.size() <= s2.size() ? s1 :s2;
}
```

内联机制用于优化规模较小、流程直接、频繁调用的函数

很多编译器不支持内联递归函数



##### **constexpr函数**

**constexpr函数是指能用于常量表达式的函数**

函数返回类型和所有形参类型都必须是**字面值类型（简单类型）**，函数体有且只有一条return语句

编译器会将函数的调用替换成其结果值，为了能在编译过程中随时展开，constexpr函数被隐式地指定为内联函数

函数体内也可以包含其他语句，但运行时不执行任何操作，比如空语句、类型别名和using声明

```c++
constexpr int new_sz(){
    return 40;
}

constexpr int foo = new_sz(); 
```

**constexpr函数的返回值也可以不是常量表达式**

```c++
//当它的实参是常量表达式，则它的返回值也是常量表达式。反之则不然
constexpr size_t scale(size_t cnt){
	return new_sz()*cnt;
}

scale(2); //常量表达式
int i = 2;
scale(i); //此时不是常量表达式
```

**内联函数和constexpr函数可以多次定义，方便编译器展开**

某个给定的内联函数或constexpr函数，它的多个定义必须完全一致。**因此它们一般定义在头文件中**

#### 调试帮助

程序可以包含一些用于调试的代码，它们只能在开发时使用。当程序编写完成准备发布时，要先屏蔽掉调试代码。它用到以下两项预处理功能

##### assert预处理宏

它是一种预处理宏，其实是一个预处理变量。

​			`assert(expr);`

**首先对表达式求值，若为假，则输出信息并终止程序的执行；若为真，则assert什么也不做**

assert宏定义在`cassert`头文件中，预处理名字由预处理器而不是编译器管理，可以直接使用预处理名字而不需要提供using声明（即不需要什么`std::assert`）

宏名字在程序中必须唯一。因此即使没有包含assert的头文件，也不要使用它（而且很多头文件会包含`cassert`，我们会间接也包含它）

assert宏常用于检查不能发生的条件。

可以将它当成调试程序的辅助手段，不能替代真正的运行时逻辑检查和错误检查

##### `NDEBUG`预处理变量

assert的行为依赖于一个叫作`NDEBUG`的预处理变量的状态

**如果定义了NDEBUG，则assert什么也不做。默认没有定义NDEBUG**

定义NDEBUG：它可以关闭调试状态

​			`#define NDEBUG`

```c++
void print(const int ia[], size_t size){
#ifndef NDEBUG
		//__func__是编译器定义的局部静态变量，存放当前函数名
		cerr << __func__ << ": array size is " << size << endl;
#endif
}	    

__FILE__  存放当前文件名
__LINE__  存放当前行号的整型字面值    
__TIME__  存放文件编译时间的字符串字面值
__DATE__  存放文件编译日期的字符串字面值    
```

### 5、函数指针

函数指针指向的是函数而非对象。**函数的类型由它的返回类型和形参类型共同决定，和函数名无关**

```c++
//它的类型是bool (const string &,const string &)
bool lengthCompare(const string &,const string &);


//pf指针指向一个函数
bool (*pf)(const string &,const string &); //未初始化
```

这里pf的括号不能缺少，如果不加括号代表pf是一个返回bool指针的函数

#### **使用函数指针**

**当我们将函数名作为一个值使用时，该函数自动地转换成指针**

**可以直接使用指向函数的指针调用函数，不需要提前解引用**

**在指向不同函数类型的指针之间不存在转换**

```c++
pf = lengthCompare; //pf指向该函数
pf = &lengthCompare; //和上面的语句等价


//三个等价调用
bool b = pf("hello","goodbye");
bool b = (*pf)("hello","goodbye");
bool b = lenghtCompare("hello","goodbye");
```

#### 函数指针形参

和数组类似，不能定义函数类型的形参，但是形参可以是指向函数的指针。

形参看起来是函数类型，实际上是指针

**decltype作用于函数时，返回函数类型**

```c++
//声明
void useBigger(const string &s1,const string &s2,
              bool pf(const string&,const string &));//第三个参数是函数类型，自动转换成函数指针
void useBigger(const string &s1,const string &s2,
              bool (*pf)(const string&,const string &)); //等价形式

//调用：直接将函数作为实参，会自动转化为指针
useBigger(s1,s2,lengthCompare);



//类型别名简化
//Func是函数类型
typedef bool Func(const string&,const string&);
typedef decltype(lengthCompare) Func; //和上一行等价，decltype不会将函数类型自动转为指针类型

//FuncP是函数指针
typedef bool (*FuncP)(const string&,const string&);
typedef decltype(lengthCompare) *FuncP; //和上一行等价，decltype不会将函数类型自动转为指针类型

//声明
void useBigger(const string&,const string&,Func);
void useBigger(const string&,const string&,FuncP);//和上一行等价
```

#### 返回指向函数的指针

**这里必须写成函数指针形式，函数不会自动地转换成指针**

```c++
//使用类型别名
using F = int(int*,int); //这是函数类型
using PF = int(*)(int*,int);  //这是函数的指针

PF f(int); //正确：返回函数指针
F f(int); //错误：F是函数类型，不能返回
F *f(int); //正确：返回函数指针

//直接声明f
int (*f(int))(int*,int);
auto f(int) -> int (*)(int*,int); //尾置返回类型
```

## 六、类

类的基本思想是数据抽象（data abstraction）和封装（encapsulation）

### 1、定义抽象数据类型

Sales_data类：

![Sales_data类](D:\office\word\计算机基础\C++\截图\Sales_data类.jpg)

**编译器分两步处理类：先编译成员的声明，然后才轮到成员函数体（如果存在）**

因此成员函数体可以随意使用类中的其他成员并且无须在意它们的次序

**类内初始值必须使用=或花括号来提供！！！**

#### 定义成员函数

定义在类内部的函数是隐式的inline函数

**所有成员都必须在类的内部声明，但是成员函数可以定义在类内或类外**

```c++
//Sales_data类的成员函数
std::string isbn() const {return bookNo;} //隐式使用了this指向的成员，即this->bookNo
std::string isbn() const {return this->bookNo;} //上面的等价形式

total.isbn(); //调用成员函数时，会将调用这个函数的对象地址用来初始化this
//即将total的地址传递给isbn的隐式形参this,相当于：isbn(&total)
```

**成员函数通过this这个隐式参数来访问调用它的那个对象，this是一个常量指针，总是指向”这个“对象**

**紧随参数列表之后的const：作用是修改隐式this指针的类型。**

**this默认是指向非常量类类型的常量指针，此时它不能绑定常量对象，不能在常量对象上调用普通的成员函数**

将this设置成`const Sales_data *const this`可以提高函数灵活性，由于this是隐式的，不会出现在参数列表，所以C++允许将其放在参数列表之后。像这样使用const的成员函数叫作**常量成员函数**

**常量成员函数不能改变调用它的对象中的内容**

#### 可变数据成员

可变数据成员（mutable data member）永远不会是const，哪怕是一个const对象的成员。因此我们可以在常量成员函数中修改它的值

```c++
class Screen{
    void member() const;
    mutable size_t a;
};
void Screen::member() const{
    ++a; //可变数据成员可以进行修改
}
```

**在类的外部定义成员函数：**

函数名必须包含所属的类名，代表它被声明在类Sales_data的作用域内

```c++
double Sales_data::avg_price() const{
    if(units_sold)			//units_sold和revenue是隐式地使用了Sales_data类的成员
        return revenue/units_sold;
    else
        return 0;
}


//返回this对象，这里修改了该对象，所以形参不需要const
Sales_data& Sales_data::combine(const Sales_data &rhs){
	units_sold += rhs.units_sold;
    revenue += rhs.revenue;
    return *this;  //this指针解引用之后得到调用对象
}

//一个常量成员函数若以引用形式返回* this，则它的返回类型将是常量引用
```

一般定义的函数类似某个内置运算符时，应该将函数的行为尽量模仿这个运算符。

这里赋值运算符把他的左侧运算对象当成左值返回，因此combine函数必须返回引用类型。

#### 定义类相关的非成员函数

这些函数概念上属于类的接口的组成部分，但实际上并不属于类本身

**它们一般需要和类声明在同一个头文件中**



#### 列表初始化

列表初始化（也称为统一初始化或花括号初始化）是一种在 C++11 及以后版本中引入的新特性，它允许你用花括号 `{}` 来初始化对象，包括自定义类型的对象。当使用列表初始化一个对象时，你可以不必显式地提供一个构造函数。编译器会尝试以下几种方式（按优先级）来初始化对象：

1. **调用带有 `std::initializer_list` 参数的构造函数。** 如果你为一个类定义了一个接受 `std::initializer_list` 为参数的构造函数，那么这个构造函数将被用来执行列表初始化。

   ```c++
   #include <initializer_list>
   #include <vector>
   
   class MyClass {
   public:
       MyClass(std::initializer_list<int> init) {
           // ...
       }
   };
   
   MyClass obj {1, 2, 3, 4}; // Calls the constructor with std::initializer_list
   ```

2. **调用与初始化列表元素数量和类型都匹配的常规构造函数。** 如果没有 `std::initializer_list` 构造函数，编译器会尝试找一个常规构造函数，它的参数数量和类型能够与初始化列表中的元素一一对应。

   ```c++
   class MyClass {
   public:
       MyClass(int a, double b) {
           // ...
       }
   };
   
   MyClass obj {1, 2.0}; // Calls the constructor with (int, double) parameters
   ```

3. **聚合初始化。** 如果类是一个聚合（即一个没有用户声明的构造函数、没有私有或保护的非静态数据成员、没有基类以及没有虚函数的类），那么它的成员将被直接初始化。

   **在C++11和C++14中，一旦你为一个数据成员提供了默认的类内初始值，该类就不再是一个聚合类。**

   ```
   struct Point {
       int x, y, z;
   };
   
   Point p {1, 2, 3}; // Directly initializes members x=1, y=2, z=3
   ```

在上述第3种情况下，**我们并没有为 `Point` 结构体定义一个构造函数，但我们仍然可以使用列表初始化 `{1, 2, 3}` 来初始化 `Point` 对象的 `x`, `y` 和 `z` 成员。**

这种特性使得初始化语法更加一致和清晰。它可以用于基本类型、数组、STL 容器、自定义类型等等，且可以避免某些类型的窄化转换。

#### 构造函数

类通过构造函数来控制其对象的初始化过程，只要类的对象被创建，就会执行构造函数

**构造函数的名字和类名相同，它没有返回类型**

**类可以包含多个构造函数，和其他重载函数类似**

**构造函数不能被声明成const的**

当创建一个const对象时，直到构造函数完成初始化过程，对象才真正取得常量属性。因此构造函数在const对象的构造过程中可以向其写值

**默认构造函数**

**类通过一个特殊的构造函数来控制默认初始化过程，即默认构造函数，它无须任何实参**

**若类没有显示定义构造函数，那么编译器会隐式定义一个默认构造函数**，也叫作**合成的默认构造函数**

如果存在类内的初始值，则用它来初始化成员。否则执行默认初始化

**若定义了其他构造函数，则编译器不会合成默认构造函数，需手动定义**

```c++
struct Sales_data{
  //默认构造函数，不接受任何实参  
  Sales_data() = default;
  
  //冒号之后的内容：构造函数初始值列表，它是成员名字的列表  
  //它负责为新创建对象的某些数据成员赋初值，每个名字后面紧跟括号或花括号内的成员初始值  
  Sales_data(const std::string &s): bookNo(s){ }//此时其他成员执行默认初始化
    
  Sales_data(const std::string &s, unsigned n, double p): bookNo(s),units_sold(n),
    		revenue(p*n){ }
  
  //类外部定义构造函数  
  Sales_data(std::istream &);  
};

Sales_data::Sales_data(std::istream &is){
    read(is,*this);//从is中读取一条信息然后存入this对象中
}
```

若一个构造函数为所有参数都提供了默认实参，则它实际上也重新定义了默认构造函数

##### const或引用成员的初始化

成员是const或引用时，必须将其初始化

当成员属于某种类类型且该类没定义默认构造函数时，也必须将这个成员初始化

```c++
class ConstRef{
public:    
    ConstRrf(int ii);
private:
    int i;
    const int ci;
    int &ri;
};

//错误：ci和ri必须进行初始化
ConstRef::ConstRef(int ii){
  i = ii;  //正确
  ci = ii; //错误：不能给const进行赋值
  ri = i;  //错误：ri被初始化
}

//正确：显示地初始化引用和const成员
ConstRef::ConstRef(int ii):i(ii),ci(ii),ri(i){}

```

##### 成员初始化顺序

**成员初始化的顺序与他们在类定义中出现的顺序一致**，与构造函数初始值列表的顺序无关

若一个成员使用另一个成员来初始化，则他们的顺序就很关键

最好的做法是将构造函数初始值的顺序和成员声明的顺序一致

#### 委托构造函数

C++11扩展了构造函数初始值的功能，可以定义委托构造函数（delegating constructor）

一个委托构造函数**使用它所属类的其他构造函数执行它自己的初始化过程**，它把它自己的一些（或全部）职责委托给了其他构造函数

委托构造函数的初始值列表只有一个唯一的入口，即类名本身。

委托构造函数的参数列表必须与类中另外一个构造函数匹配

**进行委托时，受委托的构造函数的初始值列表和函数体依次执行，然后控制权才会回到委托者的函数体中**

```c++
class Sales_data{
    //非委托构造函数
    Sales_data(std::string s,unsigned cnt,double 					 		      	price):bookNo(s),units_sold(cnt),revenue(cnt*price){ }
    
    //委托构造函数
    Sales_data():Sales_data("",0,0){} //委托第一个构造函数
    Sales_data(std::string s):Sales_data(s,0,0){}
    //先委托给默认构造函数，然后再接着委托给第一个构造函数
    Sales_data(std::istream &is):Sales_data(){read(is,*this);} 
};
```

#### 隐式的类类型转换

**若构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制**，也叫作**转换构造函数**

能通过一个实参调用的构造函数定义了一条**从构造函数的参数类型向类类型隐式转换的规则**

```c++
string null_book = "999";
//Sales_data类接受string和istream的构造函数，因此这里可以构造一个临时的Sales_data对象
//combine接受一个const Sales_data&参数
item.combine(null_book); //这里的string类型会自动创建一个Sales_data对象

//只允许一步隐式转换
item.combine("999"); //错误！！！这里会先将“999”转成string，再将其转换成Sales_data

item.combine(Sales_data("999"));//隐式地转换为string，再显示生成Sales_data对象
```

#### 抑制构造函数定义的隐式转换

可以使用**explicit**阻止隐式转换，**它只对一个实参的构造函数有效，它只允许出现在类内的构造函数声明处**

```c++
class Sales_data{
	Sales_data() = default;
    Sales_data(const std::string &s,unsigned n,double p):bookNo(s),units_sold(n),revenue(p*n){}
    //阻止隐式转换
    explicit Sales_data(const std::string &s):bookNo(s){ }
    explicit Sales_data(std::istream&);
};
```



#### **拷贝、赋值和析构**

**我们不主动定义它们，编译器一般会对类对象的每个成员执行拷贝、赋值和销毁（析构）操作**

### 2、访问控制与封装

访问说明符可以加强类的封装性

- **public**	定义在它之后的成员在整个程序内可被访问

- **private**	定义在它之后的成员可以被类的成员函数访问，但不能被使用该类的代码访问，封装（隐藏）了类的实现细节

class也可以用来定义类：

**struct中默认访问权限是public的；class中默认访问权限是private**

```c++
class Sales_data{
public:
  Sales_data() = default;
  Sales_data(const std::string &s): bookNo(s){ }//此时其他成员执行默认初始化  
  Sales_data(const std::string &s, unsigned n, double p): bookNo(s),units_sold(n),
    		revenue(p*n){ }  
  Sales_data(std::istream &);
  std::string isbn() const {return bookNo;}
  Sales_data &combine(const Sales_data&);  
private:
  double revenue = 0.0;
  double avg_price() const
  		{return units_sold ? revenue/units_sold : 0;}
  std::string bookNo;
  unsigned units_sold = 0;  
    
};
```

#### 友元

类允许其他类或函数访问它的非公有成员，方法是令它们成为该类的**友元**

友元声明只能出现在类的内部，但在内部的具体位置不限。一般在类开始或结束前的位置声明友元

友元不是类的成员，当然也不受到访问控制的约束

```c++
class Sales_data{
    //友元声明只是指定了访问权限，若需要调用此函数需要额外声明
    friend Sales_data add(const Sales_data&,const Sales_data&);
};

//Sales_data接口的非成员组成部分的声明
Sales_data add(const Sales_data&,const Sales_data&);
```

####  友元类

 如果一个类中指定了友元类，则**友元类的成员函数可以访问此类包括private的所有成员**

```c++
class Screen{
    friend class Window_mgr;
};

//为成员函数声明友元，其中必须指定它属于哪个类
class Screen{
    friend void Window_mgr::clear(ScreenIndex);
}
```

**友元关系不存在传递性！！！**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              

### 3、类类型

每个类定义了唯一的类型

```c++
//后两条语句和第一条等价，都可以作为类型名使用
Sales_data item;
class Sales_data item;
struct Sales_data item;
```

#### 类的声明

可以将类的声明和定义分离开来

这种声明叫作**前向声明。**在它声明之后定义之前是一个**不完全类型**，它的使用场景有限：

- 可以定义指向这种类型的指针或引用

- 也可以声明（但不能定义）以不完全类型作为参数或返回类型的函数

```c++
class Screen; //类的声明
```

**一个类在创建它的对象之前必须先被定义过，否则编译器就不知道这样的对象需要多少存储空间**

**一个类的成员类型不能是该类自己，因为必须完成类的定义才能知道存储数据成员需要多少空间**

**类允许包含指向它自身类型的引用或指针，一旦一个类的名字出现，它就被认为是声明过了（尚未定义）**

```c++
class Link_screen{
  Screen window;
  Link_screen *next;
  Link_screen *prev;  
};               
```

#### 类中不能重新定义外层的名字

```c++
typedef double Money;
class Account{
    Money balance() {return bal;}   //使用的是外层作用域的Money
    typedef double Money;  //错误！！！不能重新定义外层中的Money，不能重新定义外层名字
};
```

#### 类的作用域

```c++
int height;
class Screen{
    typedef std::string::size_type pos;
    pos cursor = 0,height = 0;
    void dummy_fcn(pos height){
        cursor = width * height;//使用参数height
        cursor = width * this->height; //使用类中的成员height，或者是Screen::height
        cursor = width * ::height; //使用作用域运算符获得类外层的height
    }
};
```

### 4、聚合类

**用户可以直接访问其成员，它有特殊的初始化语法形式**

聚合类满足如下条件：

- 所有成员是public的

- 没定义任何构造函数

- 无类内初始值

- 没有基类，也没有virtual函数

初始值列表的数量不能超过类的成员数量；若不足，则剩下的成员执行值初始化

```c++
struct Data{
  int ival;
  string s;
};

//使用花括号括起来的成员初始值列表来初始化聚合类
//花括号中的顺序需要与声明的顺序一致。
Data val = {0,"aaa"}; //相当于val.ival=0，val.s=string("aaa")
```

### 5、字面值常量类

某些类也是字面值类型，它们可能含有constexpr函数成员。

数据成员都是字面值类型的聚合类是字面值常量类

若一个类不是聚合类，其满足以下要求之后也是一个字面值常量类：

- 数据成员都是字面值类型
- 类必须至少含有一个constexpr构造函数
- 若存在类内初始值，内置类型的类内初始值必须是一条常量表达式；类类型的则必须使用它自己的constexpr构造函数
- 类必须使用默认的析构函数定义，它负责销毁类的对象

#### constexpr构造函数

构造函数不能是const，但是字面值常量类的构造函数可以是constexpr函数，它的函数体只能有一条return语句

一般该函数是空的，它必须初始化所有数据成员，初始值是常量表达式或使用constexpr构造函数

```c++
class Debug{
  bool hw,io;  
  constexpr Debug(bool b=true):hw(b),io(b){ }
    
};
```

### 6、类的静态成员

#### 声明、定义静态成员

关键字static可以使得成员和类关联在一起，类的静态成员存在于任何对象之外

**静态成员函数也不与任何对象绑定在一起，它们不包含this指针，因此也不能声明成const的**

静态数据成员不属于类的任何一个对象，**所以它们并不是在创建类对象时被定义的，即不是由构造函数初始化**

```c++
class Account{
  public:
    void calculate(){amount += amount * interestRate;}
    static double rate() {return interestRate;}
    static void rate(double);
  private:
    std::string owner;
    double amount;
    static double interestRate;
    static double initRate();
};


//外部定义类的静态成员时不能再重复使用static关键字
void Account::rate(double newRate){
    interestRate = newRate;
}


//外部定义并初始化
double Account::interestRate = initRate(); //从类名开始之后的部分就都位于类的作用域之内，可直接使用initRate函数
```

**一般类的静态成员不应该在类的内部初始化**，**但静态成员是字面值常量类型的constexpr时可以给它提供const整数类型的类内初始值**

静态成员仅应用于编译器可以替换它的值的情况，则不需要定义；否则需要一条定义语句

```c++
class Account{
public:
    static double rate(){return interestRate;}
    static void rate(double);
private:
    static constexpr int period = 30; //这里是常量表达式 
    double daily_tbl[period]; //period用作数组维度
};

//定义静态成员
//若在类的内部提供了一个初始值，则成员的定义就不能再指定一个初始值
constexpr int Account::period;
```

#### 使用类的静态成员

```c++
//使用作用域运算符直接访问静态成员
double r;
r = Account::rate();

//仍然可以使用类的对象、引用或指针来访问静态成员
Account ac1;
Account *ac2 = &ac1;
r = ac1.rate();
r = ac2->rate();
```

静态数据成员的类型可以是不完全类型，也就可以是它所属的类类型

```c++
class Bar{
    static Bar mem1;  //正确：静态成员可以是不完全类型
    Bar *mem2; //正确：指针成员可以是不完全类型
    Bar mem3; //错误：数据成员必须是完全类型
};
```

可以使用静态成员作为默认实参

非静态的不能作为默认实参，因为它的值属于对象的一部分

```c++
class Screen{
  Screen& clear(char = bkground);
  static const char bkground; //类外会进行定义  
};
```

## 七、IO库

c++不直接处理输入输出，而是通过一组定义在标准库中的类型来处理IO，包括向文件、控制台、窗口、string（即内存中）等地方进行读写

### 1、IO类

标准库定义了一组类型和对象来操纵wchar_t类型的数据，宽字符版本的类型和函数的名字以一个w开始

标准库通过继承机制可以使我们忽略这些不同类型的流之间的差异

比如类型ifstream和istringstream都继承自istream

![](D:\office\word\计算机基础\C++\截图\IO库类型和头文件.jpg)

#### IO对象无拷贝或赋值

由于不能拷贝IO对象，因此我们也**不能将形参或返回类型设置为流类型**

进行IO操作的函数通常**以引用方式传递和返回流**，读写一个IO对象会改变其状态，因此传递和返回的引用不能是const的

```c++
ofstream out1,out2;
out1=out2; //错误：不能对流对象赋值
ofstream print(ofstream); //错误：不能初始化ofstream参数
out2=print(out2); //错误：不能拷贝流对象

```

#### 条件状态

IO操作与生俱来的问题就是可能发生错误。一些函数和标志可以帮助我们访问和操纵流的条件状态（condition state）

iostate作为一个位集合使用，IO库定义了4个iostate类型的constexpr值，表示特定类型的IO条件，可以和位运算符一起使用

四个标志位，置位即置1，复位就是0

**到达文件结束位置eofbit和failbit都会被置位**

**badbit、failbit、eofbit任一个被置位，则检测流状态的条件会失败**

| strm::iostate     | strm是一种IO类型，iostate是一种机器无关的类型，提供表达条件状态的完整功能 |
| ----------------- | ------------------------------------------------------------ |
| **strm::badbit**  | 用来指出流已崩溃，是系统级错误，如不可恢复的读写错误。一旦被置位，流就无法使用 |
| **strm::falibit** | 发生可恢复错误后会被置位，如想读取数值却读出字符，修正问题后可以继续使用 |
| **strm::eofbit**  | 用来指出流到达了文件结束                                     |
| **strm::goodbit** | 用来指出流不处于错误状态，此时该位为0                        |

![IO库条件状态](D:\office\word\计算机基础\C++\截图\IO库条件状态.jpg)

**badbit被置位时，fail也会返回true，到达文件结束位置eofbit和failbit都会被置位**

**使用good或fail是确定流的总体状态的正确方法**

一个流一旦发生错误，后续的IO操作都会失败。因此代码通常需要在**使用一个流之前检查它是否状态良好**

最简单的方法是将它当做一个条件使用：

```c++
while(cin >> word){   //其实这里就等价于!fail()
    ...
}
```

#### 管理条件状态

- 流对象的rdstate成员返回一个iostate值，对应流当前的状态

- setstate将给定条件位进行置位，表示发生了对应的错误

- clear是一个重载成员，不接受参数的版本清除（复位）所有错误标志位。执行完clear后再调用good会返回true
- clear带参数版本接收一个iostate类型的参数，表示流的新状态

```c++
auto old_state = cin.rdstate(); //记住cin原有状态
cin.clear(); //使cin有效
process_input(cin); //使用cin
cin.setstate(old_state); //将cin置为原有状态    


//复位failbit和badbit，保持eofbit不变
cin.clear(cin.rdstate() & ~cin.failbit & ~cin.badbit);
```

#### 管理输出缓冲

**每个输出流都管理一个缓冲区，用来保存程序读写的数据**

缓冲机制有了之后，操作系统可以将多个输出操作组合成单一的系统级写操作，可以带来很大的性能提升

缓冲

### 2、文件输入输出

![](D:\office\word\计算机基础\C++\截图\fstream独有的操作.jpg)

#### 使用文件流对象

读写文件时可以**定义一个文件流对象，并且将对象与文件关联起来。**

每个文件流类都定义了open这个成员函数，定位给定的文件，打开读或写模式

创建文件流对象时，可以提供文件名（可选）。**如果提供了文件名，则open自动被调用**

```c++
ifstream in(ifile); //构造一个ifstream并且打开给定文件
ofstream out; //输出文件流未关联到任何文件
```

上面的代码定义了一个输入流in，它被初始化为从文件读取数据，文件名由string类型的参数`ifile`指定。

第二条语句定义了一个输出流out，未与任何文件关联

**新C++标准中文件名既可以是string对象，也可以是C风格字符数组**

##### **可以使用fstream代替iostream&**

在要求使用基类型对象的地方，可以用**继承类型的对象代替**

接收一个iostream类型引用（或者指针）参数的函数，可以用一个对应的fstream类型来调用

##### **成员函数open和close**

定义一个空文件流对象，可以随后调用open来将它与文件关联起来

若调用open失败，流的failbit会被置位，所以可以进行检测

```c++
ifstream in(ifile); //构建一个ifstream并打开给定文件
ofstream out;
out.open(ifile + ".copy"); //打开指定文件

//检查open是否成功
if(out){
    ...
}
```

**一旦一个文件流打开，它就保持与对应文件的关联**。对已经打开的文件流再调用open会失败，并导致failbit被置位，随后的操作都会失败

**为了将文件流关联到另一个文件，必须先关闭已经关联的文件**

```c++
in.close(); //关闭文件
in.open(ifile + "2");  //打开另一个文件
```

##### 自动构造和析构

```c++
//假设main函数接收一个需要处理的文件列表
for(auto p = argv + 1;p != argv + argc;++p){ //argv是一个C风格的字符串数组
    ifstream input(*p); //创建输出流并打开文件
    if(input){
        process(input);  //若文件打开成功，则处理它
    }
    else{
        cerr << "couldn't open + string(*p)";
    }
}
```

上面的程序每一次循环会构造一个新的名为input的ifstream对象，由于它是局部变量，它在每次循环时都要创建和销毁一次。

**当一个fstream对象离开其作用域时会被销毁，与之关联的文件会自动关闭。close会自动被调用**

#### 文件模式（file mode）

每个流都有一个关联的**文件模式**

![](D:\office\word\计算机基础\C++\截图\文件模式.jpg)

用一个文件名初始化流来隐式打开文件、调用open打开文件时都可以指定文件模式

截断文件就是删除文件已有内容

**注意：**

- out只能用于ofstream或fstream对象，in只能用于ifstream或fstream对象
- 只有out设定时才能设定trunc
- 没设定trunc，就可以设定app模式；app模式默认是out
- out默认情况下也会截断文件，可以同时指定app模式将数据追加到末尾；或者同时指定in模式，同时进行读写
- ate和binary可用于任何类型的文件流对象，可以和其他模式任意组合

**每个文件流类型都定义了默认的模式，ifstream是in、ofstream是out、fstream是in和out**

```c++
ofstream out("file1"); //默认是out，删除原有内容再写
ofstream out2("file1",ofstream::out); //和上面一样
ofstream out3("file1",ofstream::out | ofstream::trunc); //显示的截断文件

//从文件末尾输出
ofstream app("file2",ofstream::app);
ofstream app2("file2",ofstream::out | ofstream::app);
```

### 3、string流

sstream头文件定义了三个类型来支持内存IO，就像string是一个IO流一样，它继承自iostream头文件

![](D:\office\word\计算机基础\C++\截图\stringstream特有的操作.jpg)

```c++
struct PersonInfo{
    string name;
    vector<string> phones;
};

string line,word; //分别保存来自输入的一行和单词
vector<PersonInfo> people;
while(getline(cin,line)){
    PersonInfo info;
    istringstream record(line);
    record >> info.name;
    while(record >> word){
        info.phones.push_back(word);
    }
    people.push_back(info);
}


for(const auto &entry : people){ //对people中的每一项进行检查
    ostringstream formatted,badNums; //格式改变后的号码和无效号码
    for(const auto &nums :entry.phones){
        if(!valid(nums)){ //假设valid函数存在
            badNums << " " << nums;
        }
        else{
            formatted << " " << format(nums);//假定format函数存在
        }
    }
    if(badNums.str().empty())//所有号码有效,badNums为空
        os << entry.name << " " <<formatted.str() << endl;
    else
        cerr << "input error:" << entry.name 
        	 << "invalid numbers" << badNums.str() <<endl;
    
}
```

## 八、顺序容器

**元素在顺序容器中的顺序与其加入容器时的位置相对应，顺序容器中的元素按它们在容器中的位置来顺序保存和访问的**

在关联容器中元素的位置由元素相关联的关键字决定

所有容器类都共享公共的接口，不同容器按不同方式对其进行扩展，基于某种容器学习的内容也都适用于其他容器

容器是特定类型对象的集合，**顺序容器（sequential container）为程序员提供了 控制元素存储和访问顺序的能力**

### 1、概述

![](D:\office\word\计算机基础\C++\截图\顺序容器类型.jpg)

- array与内置数组相比更加安全、易用，应该多使用标准库容器，而不是原始的数据结构，比如内置数组
- **list和forward_list与其他容器相比额外内存开销很大。**若程序有很多小的元素，且空间的额外开销很重要则不要使用它们

- forward_list没有size操作，因为保存或计算其大小会比手写链表多出额外的开销。forward_list的目标就是达到与最好的手写单链表相当的性能
- 一般vector是最好的选择
- 若必须在中间位置插入元素，可以输入阶段使用list，完成后将内容拷贝到vector中
- 若程序既要随机访问又要中间位置插入，占主导地位的操作决定了容器的选择

### 2、所有容器类型共有操作

一般每个容器都定义在一个名字与类型名相同的头文件中。**容器都是模板类**

```c++
list<Sales_data>
deque<double>    
```

顺序容器几乎可以保存任意类型的元素，容器元素的类型可以是另一个容器。

某些容器操作对元素类型会有要求。比如顺序容器的一个构造函数接收容器大小这一参数，但是它使用了元素类型的默认构造函数。对于无默认构造函数的类则需要提供额外的初始化器

```c++
vector<vector<string>> lines;

//假设noDefault无默认构造函数
vector<noDefault> v(10,init);//正确：提供了元素值，全为init
vector<noDefault> v(10);//错误！！
```

**只有顺序容器的构造函数才接受表示大小的参数，关联容器不支持**

**容器操作**

![](D:\office\word\计算机基础\C++\截图\容器操作1.jpg)

![](D:\office\word\计算机基础\C++\截图\容器操作2.jpg)

```c++
//类型别名的使用
list<string>::iterator iter;
vector<int>::difference_type count;
```

#### 迭代器

迭代器也有公共的接口，若一个迭代器提供某操作，所有提供相同操作的迭代器对这个操作的实现方式相同

**迭代器范围**

一个迭代器范围由一对迭代器表示，它们分别指向同一容器中的元素或尾后位置，即begin和end(或叫first和end)，这里的end不能在begin之前，可以反复递增begin到达end

**范围左闭合的好处：**

- 若begin和end相等，则范围为空
- 若不等，则范围中至少包含一个元素，begin指向范围中的首元素
- 可以对begin递增，使他们相等

```c++
while(begin != end){
    *begin = val;
    ++begin;
}
```

#### **容器定义和初始化**

每个容器类型都定义了一个默认构造函数，**除了array之外，其他容器的默认构造函数都会创建一个指定类型的空容器，且都可以接受指定容器大小和元素初始值的参数**

![](D:\office\word\计算机基础\C++\截图\容器定义和初始化.jpg)

##### 容器初始化为另一个容器的拷贝

- 直接拷贝整个容器，两个容器的类型及其元素类型必须匹配
- array除外，可以用传递迭代器参数来指定元素范围，不要求容器类型相同，元素类型也可以不同（只要可以类型转换）

```c++
list<string> authors = {"aa","bb","cc"};
vector<const char*> articles = {"k","m","n"};

list<string> list(authors); //正确：类型匹配
deque<string> authList(authors); //错误！！！容器类型不匹配
vector<string> words(articles); //错误！！！容器类型不匹配
forward_list<string> words(articles.begin(),articles.end()); //正确：const char*可以转化为string

//拷贝子序列,不包括迭代器it指向的元素
deque<string> authList(authors.begin(),it);
```

##### 标准库array具有固定大小

定义一个array时，除了指定元素类型，还需指定容器大小。因此array不支持普通的容器构造函数

**与其他容器不同，默认构造的array是非空的，元素会默认初始化。它的元素类型若是类类型，必须有一个默认构造函数可以进行值初始化**

**array不同于内置数组类型，array可以拷贝或对象赋值**

```c++
//后面的数字均为大小
array<int,42>;
assay<string,10>;

array<int,10> digits = {1,2,3};
array<int,10> copy = digits;
```

#### 赋值和swap

![赋值](D:\office\word\计算机基础\C++\截图\容器赋值运算.jpg)

以上的运算可用于所有容器，赋值运算将左边容器的所有元素全部替换为右边元素的拷贝

若左右两边容器的元素数量不等，则赋值后左边的元素数量变为右侧的数量

**由于右侧的大小和左侧可能不同，array不支持assign，也不允许用花括号赋值**

```c++
c1 = c2;//本来c2是两个元素
c1 = {a,b,c};  //元素变为3个

array<int,10> a = {0}; //所有元素值为0
a = {0};//错误！！！不能将花括号列表赋值给array
```

##### 使用assign（仅顺序容器）

它仅支持顺序容器，其中还不包括array

assign允许从一个不同但元素相容的类型赋值，或从容器的一个子序列赋值

```c++
list<string> names;
vector<consr char*> oldstyle;
names.assign(oldstyle.cbegin(),oldstyle.cend());
```

##### **使用swap**

交换两个相同类型容器的内容

除了array之外，交换两个容器内容的操作会很快，元素本身并未交换，swap交换了两个容器内部的数据结构，不会对任何元素进行拷贝、删除或插入

由于元素不会移动，除string外指向容器的迭代器、引用和指针在swap之后不会失效，它们仍指向swap操作之前所指向的那些元素。而string调用swap会导致它们失效

**swap两个array会交换它们的元素值，因此元素越多，交换时间越长，指针等绑定的元素保持不变，但是元素值进行了交换**

```c++
vector<string> svec1(10);
vector<string> svec2(20);
swap(svec1,svec2);
```

一般统一使用非成员版本的swap，这在泛型编程中很重要

#### 容器大小操作

每个容器类型都有三个与大小相关的操作（除了forward_list，它只支持max_size和empty，不支持size）

- size返回容器中元素的数目

- empty是元素为空返回true，否则false

- max_size返回一个大于或等于该类型容器所能容纳的最大元素数的值

#### 关系运算符

每个容器类型都支持`==`和`!=`

除了无序关联容器外的其他容器都支持关系运算符（> < >= <=），它们左右两侧的运算对象必须是相同类型的容器，且元素类型相同

比较两个容器实际上是进行元素的逐对比较：

- 两个容器大小相等且元素相等，则两个容器相等
- 两个容器大小不同，但较小容器中的元素和另一个相同，则较小容器小于较大容器
- 若两个容器都不是另一个的前缀子序列，则比较结果取决于第一个不相等的元素的比较结果

**只有当其中的元素类型也定义了相应的比较运算符时，我们才可以使用关系运算符来比较两个容器**

### 3、顺序容器中的操作

#### 添加元素

![](D:\office\word\计算机基础\C++\截图\顺序容器添加元素.jpg)

除array外，所有的标准库容器都可以动态添加或删除元素

**除了array和forward_list，每个顺序容器都支持push_back（包括string也可以）**

```c++
string word;
while(cin >> word){
    container.push_back(word);//每次读取一个string到word，并添加到容器尾部
}
```

**注：容器元素是拷贝，在用对象初始化容器或将对象插入容器时，实际上放入到容器中的是对象值的一个拷贝，不是对象本身，对容器中元素的改变不会影响原始对象，反之亦然**

##### push_front

list、forward_list、deque支持push_front，将元素插入到容器头部

```c++
list<int> ilist;
for(size_t ix = 0;ix != 4;++ix)
    ilist.push_front(ix);  //形成逆序
```

##### 在容器特定位置添加元素

vector、deque、list、string都支持insert，forward_list提供了特殊的insert成员

insert第一个参数是迭代器，由于迭代器可以指向尾后，并且在开始位置插入元素很有用，因此**insert将元素插入迭代器指定位置之前**

```c++
vector<string> svec;
vector<string> v = {"a","b","c"};

svec.insert(svec.begin(),"hello");
svec.insert(svec.end(),10,"anna"); //将10个anna插入末尾
svec.insert(svec.begin(),v.end()-2,v.end());
svec.insert(svec.begin(),{"j","k","m"});

svec.insert(svec.begin(),svec.begin(),svec.end());//错误！！！后面的范围不能指向自己的元素


//使用insert的返回值
list<string> lst;
auto iter = lst.begin();
while(cin >> word)
    iter = lst.insert(iter,word);//等价于调用push_front
```

##### 使用emplace操作

emplace是构造元素，而不是拷贝，**我们将它的参数传递给了元素类型的构造函数，直接在容器管理的内存中构造元素**

**传递给emplace的参数必须与元素类型的构造函数匹配**

```c++
//c中保存Sales_data元素
//在c的末尾构造一个Sales_data对象
c.emplace_back("978",25,15.99);
c.push_back(Sales_data("978",25,15.99));

c.emplace_back(); //使用Sales_data的默认构造函数
```

#### 访问元素

若容器中无任何元素，则访问操作的结果是未定义的

**每个顺序容器（包括array）都有一个front成员函数，除了forward_list之外的所有顺序容器都有一个back成员函数。它们分别返回首元素和尾元素的引用**

```c++
if(!c.empty()){
    auto val = *c.begin(),val2 = c.front(); //val和val2是第一个元素值的拷贝
    
    //val3和val4是最后一个元素值的拷贝
    auto last = c.end();
    //以下操作forward_list不支持
    auto val3 = *(--last); 
    auto val4 = c.back();
}
```

![](D:\office\word\计算机基础\C++\截图\顺序容器访问操作.jpg)

##### 访问成员函数返回的是引用

在容器中访问元素的成员函数返回的都是引用。若容器是const对象，则返回值是const引用

```c++
if(!c.empty()){
    c.front() = 42;
    auto &v = c.back();
    v = 1024;  //改变c中的元素
    auto v2 = c.back();
    v2 = 0; //v2只是一个拷贝，未改变c中的元素
}
```

**at可以确保下标合法，若越界，它会抛出一个out_of_range异常**

#### 删除元素

![](D:\office\word\计算机基础\C++\截图\顺序容器删除操作.jpg)

删除元素的成员函数不检查它的参数，我们必须确保参数存在

**vector和string不支持pop_front**

```c++
//若需要弹出的元素值，需要先保存
while(!ilist.empty()){
    process(ilist.front()); //先进行保存
    ilist.pop_front();
}

//删除奇数元素
list<int> lst = {0,1,2,3,4,5,6};
auto it = lst.begin();
while(it != lst.end()){
    if(*it %2)
        it = lst.erase(it);
    else
        ++it;
}

//删除多个元素，返回最后一个被删元素之后位置的迭代器
//elem2指向要删除的最后一个元素之后的位置
elem = slist.erase(elem1,elem2); //elem == elem2
```

#### 特殊的forward_list操作

单链表增删元素会改变前面元素的后继，因此需要访问它的前驱，但是单链表不能简单的访问前驱

在forward_list中添加或删除元素是通过改变给定元素之后的元素完成的，因此它的增删与其他容器不同

![](D:\office\word\计算机基础\C++\截图\forward_list增删操作.jpg)

```c++
//删除奇数
forward_list<int> flst = {0,1,2,3,4,5,6};
auto prev = flst.before_begin();
auto curr = flst.begin();
while(curr != flst.end()){
    if(*curr % 2)
        curr = flst.erase_after(prev);
    else{
        prev=curr;
    	++curr;
    }    
}
```

#### 改变容器大小

![](D:\office\word\计算机基础\C++\截图\顺序容器大小.jpg)

若容器是类类型元素，且resize向容器添加新元素，则必须提供初始值，或元素类型必须提供一个默认构造函数

### 4、vector对象增长的方式

当必须获取新的内存空间时，vector和string的实现通常会分配比新的空间需求更大的内存空间，这样就不需要每次新增元素都重新分配内存空间。这样它的扩张操作比list和deque更快

![](D:\office\word\计算机基础\C++\截图\vector内存扩张.jpg)

reserve不改变容器中元素的数量，它仅仅影响vector预先分配多大的内存空间

**当需要的空间超过当前容量，reserve调用才会改变vector的容量。**

**需求大于当前容量，则reserve至少分配与需求一样大的内存；若需求不超过当前容量，则reserve什么也不做。调用reserve永远不会减少内存**

**shrink_to_fit可以退回不需要的内存，但是具体的实现可以选择忽略此请求，不一定会退回**

### 5、额外的string操作

#### 构造string的其他方法

![](D:\office\word\计算机基础\C++\截图\构造string的其他方法.jpg)

**这些构造函数接收string或const char *参数**

![](D:\office\word\计算机基础\C++\截图\string构造函数例子.jpg)

#### substr操作

![](D:\office\word\计算机基础\C++\截图\substr操作.jpg)

```c++
string s("hello world");
string s2 = s.substr(0,5); //hello
string s3 = s.substr(6); //world
string s3 = s.substr(6,11); //world，只到末尾
string s4 = s.substr(12); //out_of_range异常
```

#### 改变string的其他方法

![](D:\office\word\计算机基础\C++\截图\修改string的操作.jpg)

![](D:\office\word\计算机基础\C++\截图\修改string的操作续表.jpg)

**string中的insert和erase可以接收下标：**

```c++
//插入给定下标之前,即末尾插入5个感叹号
s.insert(s.size(),5,'!');
//从给定下标开始删除5个元素
s.erase(s.size()-5,5);
```

#### string搜索操作

![](D:\office\word\计算机基础\C++\截图\string搜索操作.jpg)

![](D:\office\word\计算机基础\C++\截图\string搜索操作续表.jpg)

**搜索返回`string::size_type`；string::npos是静态成员，它为-1**

```c++
string name("annaList");
auto pos1 = name.find("anna"); //0，这里不要用int，因为返回的是无符号类型
    
string nums("0123456789"),name("r2d");
auto pos = name.find_first_of(nums); //1
string dept("01234p3");
auto pos2 = dept.find_first_not_of(nums);//5
```

#### compare函数

![](D:\office\word\计算机基础\C++\截图\s.compare.jpg)

#### 数值转换

![](D:\office\word\计算机基础\C++\截图\数值转换.jpg)

```c++
int i = 42;
string s = to_string(i);

```

### 6、容器适配器（adaptor）

三个顺序容器适配器：stack、queue、priority_queue

容器适配器接收一种已有的容器类型，使其行为看起来像一种不同的类型

![](D:\office\word\计算机基础\C++\截图\容器适配器.jpg)

#### 定义一个适配器

**默认stack和queue是基于deque实现的，priority_queue是在vector上实现的**

可以在创建适配器时将一个命名的顺序容器作为第二个类型参数，用来重载默认容器类型

**所有适配器都要求容器可以增删元素、访问尾元素，因此不能构造在array和forward_list上**

```c++
//deq是deque<int>，这里会拷贝deq的元素来初始化适配器
stack<int> stk(deq);

//重载默认容器类型
stack<string,vector<string>> str_stk;
stack<string,vector<string>> str_stk2(svec);
```

#### 栈适配器

**头文件stack**

![](D:\office\word\计算机基础\C++\截图\栈操作.jpg)

它只要求push_back、pop_back和back操作，**可以使用除了array和forward_list之外的任何容器类型来构造**

```c++
stack<int> intStack; //空栈
for(size_t ix=0; ix!=10; ++ix)
    intStack.push(ix);
while(!intStack.empty()){
    int val = intStack.top();
    intStack.pop();
}
```

#### 队列适配器

**头文件queue**

queue要求back、push_back、front、push_front，**因此它可以构造于list和deque之上，图片更正：不能基于vector！！**

priority_queue要求随机访问、front、push_back、pop_back，因此可构造于vector或deque上

![](D:\office\word\计算机基础\C++\截图\队列操作.jpg)

![](D:\office\word\计算机基础\C++\截图\队列操作续.jpg)

**图片更正：`q.pop();`弹出队首元素但不返回其值！！！**

## 九、泛型算法

标准库提供了一组算法，它们大多独立于任何特定容器，它们是通用的（泛型的），可以用于不同类型的容器和不同类型的元素

### 1、概述

**大部分算法定义在头文件algorithm中，标准库还在头文件numeric中定义了数值泛型算法**

算法并不直接操作容器，而是遍历两个迭代器指定的元素范围，对其中的元素进行处理

**find返回指向第一个等于给定值元素的迭代器，若无匹配元素则返回第二个参数代表搜索失败**

```c++
//查找vector<int>是否有特定值，调用标准库算法find
int val = 42;//想要查找的值
//若找到则指向它，否则结果为vec.cend()
auto res = find(vec.cbegin(),vec.cend(),val);
cout << "the value" << val << (res == vec.cend() ? "isn't present" : "is present")
     <<endl;

//find在数组中查找值
int ia[] = {1,2,7,10,5};
int val = 10;
int *res = find(begin(ia),end(ia),val);
auto res2 = find(ia+1,ia+4,val); //在其子序列查找，不包括ia+4
```

**迭代器令算法不依赖于容器，算法永远不会执行容器的操作，永远不会改变底层容器的大小。算法可能改变容器中保存元素的值，也可能在容器内移动元素，但永远不会直接增删元素**

**泛型算法只会运行在迭代器之上，执行迭代器的操作。后面会接触特殊的迭代器——插入器（inserter），他可以在底层容器上执行插入，但是算法自身不会做这样的操作**

算法依赖于元素类型的操作，比如find用元素类型的==运算符完成与给定值的比较。大部分算法允许我们使用自定义的操作来代替默认的运算符

### 2、初始泛型算法

除了少数例外，标准库算法都对一个范围内的元素进行操作，它们前两个参数来表示此范围（首指针和尾后指针）。算法使用范围中元素的方式不同，包括读取元素、改变元素、重排元素顺序

#### 只读算法

读取输入范围内的元素，不会改变元素，比如**find和count（返回给定值在序列中出现的次数，头文件为algorithm）。最好使用cbegin和cend**

**accumulate定在头文件numeric中，前两个指出需要求和的元素范围，第三个参数是和的初值**

```c++
//求和，第三个参数的类型决定了函数中使用哪个加法运算符和返回值的类型
int sum = accumulate(vec.cbegin(),vec.cend(),0);

//这里由stirng定义了+运算符，所以可以将vector中的string元素连接起来，初始为空串
//这里显示创建了stirng，直接将空串当做字符串字面值传入不行
string sum = accumulate(v.cbegin(),v.cend(),string(""));
string sum = accumulate(v.cbegin(),v.cend(),"");//报错！！const char*未定义+运算符
```

它的第三个参数代表序列中的元素类型必须与第三个参数匹配或能转换为第三个参数的类型

##### 操作两个序列

equal用于确定两个序列是否保存相同的值，将第一个序列的每个元素和第二个序列中的对应元素进行比较，**若全部对应相等则返回true，否则返回false**

前两个参数还是表示第一个序列中的元素范围，第三个参数表示第二个序列的首元素。

**equal假定第二个序列至少和第一个一样长，接收单一迭代器来表示第二个序列的算法都假定第二个序列至少与第一个序列一样长**

**equal可以比较两个不同类型容器中的元素，而且元素类型也不必一样，只要能用==来比较他们的类型即可。**

```c++
equal(roster1.cbegin(),roster1.cend(),roster2.cbegin());
//比如这里的roster1可以是vector<string>，而roster2可以是list<const char*>
```

#### 写容器元素的算法

一些算法将新值赋予序列中的元素，**必须注意确保序列原大小至少不小于我们要求算法写入的元素数目**

某些算法会自己向输入范围写入元素，它们本质上不危险，最多写入和给定序列一样多的元素，比如fill

**fill将第三个参数的值赋予序列中的每个元素**

```c++
fill(vec.begin(),vec.end(),0); //将每个元素重置为0 
```

**fill_n接收一个单迭代器，一个计数值和一个值，从指定位置开始赋值**

```c++
vector<int> vec(10);
fill_n(vec.begin(),vec.size(),1); //所有元素重置为1

vector<int> vec;
fill_n(vec.begin(),10,0);//错误！！！vec中没有10个元素，不能赋值
```

##### back_inserter函数

**back_inserter定义在头文件iterator中，接收一个指向容器的引用，返回一个与该容器绑定的插入迭代器，通过此迭代器赋值时，赋值运算符会调用push_back将一个元素添加到容器中**

保证算法有足够元素空间来容纳写入数据的方法是使用插入迭代器

```c++
vector<int> vec;
auto it = back_inserter(vec);
*it = 42; //vec中现在有一个元素，值为42

vector<int> vec;
//每次都会在vec上调用push_back，向vec末尾添加了10个元素
fill_n(back_inserter(vec),10,0);//正确！！插入迭代器可以向vec添加元素
```

##### 拷贝算法

copy接收三个迭代器，前两个表示一个范围，第三个表示目的序列的起始位置，将这个范围中的元素拷贝到目的序列

copy返回目的位置迭代器递增后的值

```c++
int a1[] ={0,1,2,3,4,5};
int a2[sizeof(a1)/sizeof(*a1)];//保证大小一样
//ret指向拷贝到a2的尾后位置
auto ret = copy(begin(a1),end(a1),a2);//将a1内容拷贝给a2
```

多个算法提供拷贝版本，会创建新序列保存结果。

比如replace，它将原序列所有等于给定值的元素替换为新值，它的拷贝版本则保持原序列不变

```c++
replace(ilist.begin(),ilist.end(),0,42); //将所有的0改为42

//保持原序列不变，第三个迭代器参数指出新序列保存的位置
//ivec会包含ilist的拷贝，会将0替换为42
replace_copy(ilist.cbegin(),ilist.cend(),back_inserter(ivec),0,42);
```

#### 重排容器元素的算法

sort会对元素进行排序，接收两个迭代器，表示排序范围

unique重排序列，令不重复元素出现在开始部分，返回指向不重复范围尾后的迭代器。unique会覆盖相邻的重复元素，它不真正删除任何元素

```c++
void elimDups(vector<string> &words){
    sort(words.begin(),words.end());
    //unique返回指向不重复区域之后一个位置的迭代器
    auto end_unique = unique(words.begin(),words.end());
    words.erase(end_unique,words.end());//删除重复
}
```

这里即使已经没有重复元素，调用erase也是安全的，因为这时unique会返回`words.end()`，删除空范围没什么不良后果

### 3、定制操作

很多算法会比较序列中的元素，它们默认使用<或==运算符完成比较。我们可以自己提供定义的操作代替默认运算符

**比如sort默认使用<运算符**，但我们希望的排序顺序可能和<定义的不同或者序列中的类型未定义<运算符。这时我们需要重载sort的默认行为

#### 向算法传递函数

sort的重载版本接收第三个参数，它是一个**二元谓词（predicate），可以理解成一个函数**

##### 谓词

谓词是一个可调用的表达式，它的返回结果是一个能用作条件的值。**谓词分为一元谓词和二元谓词，指它们分别接收单一参数和两个参数**

接收谓词作为参数的算法**会对序列中的元素调用谓词（可以理解成一个函数），因此元素类型必须能转换为谓词的参数类型**

```c++
bool isShorter(const stirng &s1,const string &s2){
    return s1.size() <s2.size();  
}

sort(words.begin(),words.end(),isShorter);//按长度排序，由短至长排序

//stable_sort可以在排序时维持相等元素的原有顺序
elimDups(words);//先字典序排列
stable_sort(words.begin(),words.end(),isShorter);//按照长度重排，同时长度相同保持原来的字典序
```

#### lambda表达式

一个lambda表达式表示一个可调用的代码单元，可以理解为一个**未命名的内联函数**。它有返回类型、参数列表和函数体，但它和函数不同，lambda可能定义在函数内部

```
[capture list](parameter list) -> return type {function body}
```

**捕获列表（capture list）是一个lambda所在函数中定义的局部变量的列表，一般为空**

其他部分和普通函数一样，但**它必须使用尾置返回来指定类型               **

**可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体。忽略括号和参数列表等价于指定一个空参数列表**

**忽略返回类型时，lambda会根据函数体的代码判断返回类型。若函数体只是一条return语句，则返回类型根据返回的表达式类型判断**

**若lambda的函数体未指定返回类型，并且包含任何单一return语句之外的内容，则返回void**

```
auto f = []{return 42;};//定义了可调用的对象f，它不接受参数

//调用方式和普通函数一样
cout << f() << endl;
```

**向lambda传递参数**

lambda不能有默认参数，调用lambda的实参数目永远和形参数相等

**空捕获列表指这个lambda不使用它所在函数中的任何局部变量**

```
[](const stirng &a,const string &b){return a.size()<b.size();}
```

**使用捕获列表**

lambda只能使用函数中明确指明的局部变量，它将要使用的局部变量放在捕获列表中，不放入其中的则不能使用

**捕获列表只用于局部非static变量，lambda可以直接使用局部static变量和函数之外声明的名字**

**捕获列表中以逗号分隔名字列表**

```
[sz](const string &a){return a.size() >= sz;};
```

#### 应用lambda表达式

**向函数传递一个lambda时，lambda会立即执行**

根据算法接收一元谓词还是二元谓词，我们传递给算法的谓词也必须严格接收一个或两个参数。但是我们有时需要操作更多的参数

##### find_if函数

它接收一对迭代器，表示范围。第三个参数接收一个一元谓词。**它返回第一个使谓词返回非0值的元素迭代器，若不存在则返回第二个迭代器参数**

由于它只接受一元谓词，这时可以使用lambda表达式

```c++
//获取一个迭代器，指向第一个满足size() >= sz的元素
auto wc = find_if(words.begin(),words.end(),
			[sz](const string &a)
			{return a.size() >= sz;});
			
auto count = words.end() - wc;	//计算满足size >=sz的元素数目
cout << count << " " << make_plural(count,"word","s") << endl;

//make_plural中第一个参数大于1，则返回后两个参数的拼接，否则返回第二个参数
```

##### for_each算法

**前两个参数仍然是范围，它第三个参数接收一个可调用对象，并对范围中的每个元素调用此对象**

```c++
//打印长度大于等于给定值的元素
for_each(wc,words.end(),
        [](const string &s){cout << s << ""};);
cout << endl;
```

```c++
//汇总版本
void biggies(vector<string> &words,vector<string>::size_type sz){
    elimDups(words); //按字典序排序，删除重复单词
    //按照长度排序，长度相同的维持字典序
    stable_sort(words.begin(),words.end(),
               [](const string &a,const string &b){return a.size() <b.size();});
    //找出第一个满足size()>=sz的元素迭代器
    auto wc = find_if(words.begin(),words.end(),
			[sz](const string &a)
			{return a.size() >= sz;});
    auto count = words.end() - wc;	//计算满足size >=sz的元素数目
	cout << count << " " << make_plural(count,"word","s") << endl;
    //打印长度大于等于给定值的元素
    for_each(wc,words.end(),
        [](const string &s){cout << s << ""};);
	cout << endl;    
    
}
```

#### lambda捕获和返回

**定义一个lambda时，编译器生成一个与lambda对应的新的未命名的类类型，后续会介绍这种类如何生成**

**当向一个函数传递lambda时，同时定义了一个新类型和该类型的一个对象：向函数传递的参数就是此类类型的未命名对象。**

类似的，使用auto定义一个用lambda初始化的变量时，定义了一个从lambda生成的类型的对象

默认情况下，从lambda生成的类都包含一个对应它所捕获变量的数据成员，它的数据成员也在lambda对象创建时被初始化

##### 值捕获

变量的捕获方式也可以是值或引用。

**被捕获变量的值是在lambda创建时拷贝，而不是调用时拷贝**

```c++
void fun(){
    size_t v = 42;
    auto f = [v1] {return v1; };
    v = 0;
    auto j = f(); //j为42，f保存了创建它时v的拷贝，后续在函数中修改v不会影响lambda内v的值
}
```

##### 引用捕获

```c++
void fun(){
    size_t v = 42;
    auto f = [&v] {return v;}; //这里代表以引用捕获
    v = 0;
    auto j = f(); //j为0，这里保存的是引用
}
```

**可以从一个函数返回lambda。函数可以直接返回一个可调用对象或返回类对象，该类含有可调用对象的数据成员**

**应该尽量避免捕获指针或引用，因为必须确保lambda执行时他们仍存在，并且它们可能后续会发生改变**

##### 隐式捕获

可以让编译器根据lambda中的代码推断我们需要使用什么变量，**这时在捕获列表写一个`=或&`**

**&代表采用捕获引用方式，=则代表值捕获**

**混合使用时，若隐式是值捕获，则显式只能是引用方式；若隐式是引用捕获，则显式只能是值捕获**

```c++
find_if(words.begin(),words.end(),
       [=](const stirng &s)
        {return s.size() >= sz;});

//混合使用隐式捕获和显示捕获，可以一部分变量采用值捕获，一部分采用引用捕获
//混合使用时捕获列表中第一个元素必须是&或=，指定默认捕获方式
void biggies(vector<string> &words,
            vector<string>::size_type sz,
            ostream &os = cout,char c = ' '){
for_each(words.begin(),words.end(),
        [&,c](const string &s){os << s << c;});//os是隐式捕获，引用方式；c是显式捕获，值捕获
for_each(words.begin(),words.end(),
        [=,&os](const string &s){os << s << c;});//c是隐式，值捕获；os是显式，引用捕获
}    
```

#### 可变lambda

**默认情况下，对于一个值被拷贝的变量，lambda不会改变其值。**若想要改变一个被捕获变量的值，**必须在参数列表后加上关键字mutable**

```c++
void func(){
    size_t v = 42;
    auto f = [v]()mutable {return ++v;};
    v = 0;
    auto j = f(); //j的值为43
}
```

**一个引用捕获的变量是否可以修改依赖于它指向的是const还是非const，和别的地方是一样的**

```c++
void func(){
	size_type v = 42;
    auto f = [&v]{return ++v;};
    v = 0;
    auto j = f(); //j为1
}
```

#### 参数绑定

对于只在一两个地方使用的简单操作，lambda表达式最有效。若需要在很多地方使用相同的操作，应该定义一个函数。

##### 标准库bind函数

它定义在头文件functional中，**可以将bind看作一个通用的函数适配器，它接收一个可调用对象，生成一个新的可调用对象来适应原对象的参数列表**

```
auto newCallable = bind(callable,arg_list);
```

**newCallable本身是一个可调用对象，arg_list是逗号分隔的参数列表，对应给定的callable的参数**

当我们调用newCallable时，它会调用callable，并传递给它arg_list中的参数

arg_list中的参数可能包含形如`_n`的名字，n是一个整数，**这是占位符**，表示是newCallable的参数，它们占据了传递给newCallable的参数的位置。`_1`表示newCallabe第一个参数，`_2`表示第二个，以此类推

```c++
bool check_size(const string &s,string::size_type sz){
    return s.size() >= sz;
}

//check6是一个可调用对象，接收一个stirng类型的参数
//调用check6会将传入的string和6再来调用check_size
auto check6 = bind(check_size,_1,6);
```

以上的例子中只有一个占位符，表示check6只接受单一参数。占位符出现在arg_list的第一个位置，代表此参数对应check_size中的第一个参数

```c++
string s = "hello";
bool b= check6(s); //check6会调用check_size(s,6)

//可以使用bind替换lambda表达式
auto wc = find_if(words.begin(),words.end(),bind(check_size,_1,sz));
```

##### 使用placeholders名字

placeholders命名空间也定义在头文件functional中

**名字`_n`都定义在叫作placeholders的命名空间中，而这个命名空间本身定义在std中**

为了使用这写名字，需要加上两个命名空间。和前面一样，我们假定刚刚的代码使用了using声明：

```c++
using std::placeholders::_1;
```

对于每个站位符名字，都必须提供单独的using声明，这样很繁琐。可以进行如下操作：

```c++
using namespace namespace_name;//这就代表所有来自namespace_name的名字都可以在程序中直接使用

using namespace std::placeholders;//使得所有其中定义的名字都能直接使用
```

##### bind的参数

```c++
auto g = bind(f,a,b,_2,c,_1);
```

这里的五个参数会按顺序传给f

调用g时，传递给g的参数按位置绑定到占位符，第一个参数绑定到`_1`，第二个参数绑定到`_2`。因此**bind可以重排参数顺序**

##### 绑定引用参数

**默认bind中那些不是占位符的参数是被拷贝到bind返回的可调用对象中，即使传入引用类型也不行**

但是有些参数我们想要以引用方式传递或类型不能拷贝，若我们想传递给bind一个对象又不拷贝它，就必须使用标准库**ref函数**

**ref返回一个对象，包含传入ref参数的引用，此对象是可以拷贝的**

**cref函数生成一个保存const引用的类，它们也定义在头文件functional中**

```c++
ostream &print(ostream &os,const stirng &s,char c){
    return os << s <<c;
}

for_each(words.begin(),words.end(),
		bind(print,ref(os),_1,' '));

for_each(words.begin(),words.end(),
		bind(print,os,_1,' ')); //错误！！不能拷贝os这个流对象
```

### 4、再探迭代器

标准库在**头文件iterator**中还定义了额外几种迭代器

**插入迭代器、流迭代器、反向迭代器、移动迭代器**

#### 插入迭代器

它是一种迭代器适配器，接受一个容器，生成一个迭代器，可以向给定容器添加元素

![](D:\office\word\计算机基础\C++\截图\插入迭代器操作.jpg)

插入器有三种类型：

- **back_inserter**	创建一个使用push_back的迭代器
- **front_inserter**    创建一个使用push_front的迭代器
- **inserter**               创建一个使用insert的迭代器，它接收第二个参数，这个参数是指向给定容器的迭代器，**元素将被插入到给定迭代器之前的位置**

**只有在容器支持push_front的情况下才能使用front_inserter，back_inserter也是如此**

当使用inserter(c,iter)时，会得到一个迭代器，使用它时会将元素插入到iter指向元素之前的位置

```c++
*it = val;//it是inserter生成的迭代器

//等价形式
iter = c.insert(iter,val);
++iter;


list<int> lst={1,2,3,4};
list<int> lst2,lst3;
//lst2为4,3,2,1
copy(lst.cbegin(),list.cend(),front_inserter(lst2));

//lst3为1,2,3,4，这是因为lst3.begin()只是指向了一开始的begin，在向他之前插入元素时它并没有改变
copy(lst.cbegin(),lst.cend(),inserter(lst3,lst3.begin()));
```

#### iostream迭代器

虽然iostream类型不是容器，但标准库定义了可以用于这些IO类型对象的迭代器

istream_iterator读取输入流，ostream_iterator向一个输出流写数据，这些迭代器将它们对应的流当作一个特定类型的元素序列来处理

##### istream_iterator操作

**创建流迭代器时，必须指定迭代器将要读写的对象类型**

`istream_iterator`默认初始化是尾后迭代器，`istream_iterator`可以绑定一个流

`in1 == in2`代表它们绑定到相同的输入流或都是尾后迭代器

```c++
istream_iterator<int> int_eof;//尾后迭代器
istream_iterator<int> int_it(cin); //从cin读取int

ifstream in("afile");
istream_iterator<string> str_it(in); //从afile读取字符串


istream_iterator<int> in_iter(cin);
istream_iterator<int> eof;
while(in_iter != eof){ //绑定到流的迭代器一旦关联的流遇到IO错误或文件尾都会与尾后迭代器相等
    vec.push_back(*in_iter++);
}


//可以使用迭代器范围构造vec
istream_iterator<int> in_iter(cin),eof;
vector<int> vec(in_iter,eof);

//使用accumulate
istream_iterator<int> in(cin),eof;
cout << accumulate(in,eof,0) << endl;
```

`istream_iterator`绑定到流时并不保证立即从流读取数据，可以推迟，直到使用迭代器时才真正读取。**允许懒惰求值**

**标准库保证在我们第一次解引用迭代器之前，完成从流中读取数据的操作**

##### ostream_iterator操作

创建ostream_iterator时，**有可选的第二参数，它是一个字符串，在输出每个元素后都会打印此字符串。它必须是一个C风格的字符串（即字符串字面常量或空字符结尾的字符数组的指针）**

**ostream_iterator必须绑定到指定流，不允许空的或尾后位置**

![](D:\office\word\计算机基础\C++\截图\ostream_iterator操作.jpg)

```c++
ostream_iterator<int> out_it(cout," ");
for(auto e : vec)
    *out_it++ = e;//这里的*和++其实对out_it对象不做任何事情，可以忽略，但是推荐使用，与别的迭代器一致
	out_it = e;//与上面是等价的
cout << endl;

//使用copy来打印vec中的元素
copy(vec.begin(),vec.end(),out_it);
cout << endl;
```

##### 使用流迭代器处理类类型

**只要定义了<<或>>运算符的类型就可以创建流迭代器对象**

```c++
istream_iterator<Sales_item> item_it(cin),eof;
ostream_iterator<Sales_item> out_it(cout,"\n");

Sales_item sum = *item_it++;
while(item_it != eof){
    if(item_it->isbn() == sum.isbn())
        sum += *item_it++;
    else{
        out_it = sum;
        sum = *item_it++;
    }
}
out_it = sum;
```

#### 反向迭代器

在容器中从尾元素向首元素反向移动的迭代器，递增会使它移动到前一个元素；递减会移动到下一个元素

**除了forward_list之外，其他容器都支持反向迭代器**

**只能从既支持`++`也支持`--`的迭代器来定义反向迭代器，流迭代器不支持递减。因此不能从forward_list或流迭代器创建反向迭代器**

可以调用**rbegin、rend、crbegin、crend**成员函数来获得反向迭代器，它们返回指向容器尾元素和首元素之前一个位置的迭代器

```c++
vector<int> vec = {1,2,3,4,5};
for(auto r_it = vec.crbegin();r_it != vec.crend();++r_it)
    cout << *r_it << endl;// 5 4 3 2 1

//可以向sort传递反向迭代器将vecotr整理为递减序
sort(vec.begin(),vec.end());
sort(vec.rbegin(),vec.rend()); //逆序排序，最小元素出现在末尾
```

```c++
//在一个逗号分隔的string中查找第一个单词
//若line中有逗号，则comma指向逗号；若没有逗号，comma指向尾后指针
auto comma = find(line.cbegin(),line.cend(),',');
cout << string(line.cbegin(),comma) << endl;

//希望打印最后一个单词，改用反向迭代器，比如line中是FIRST,LAST
auto rcomma = find(line.crbegin(),line.crend(),',');//这里的rcomma是反向迭代器
//这里会发生错误,打印出TSAL
cout << string(line.crbegin(),rcomma) << endl;

```

上面的例子中打印出的单词是反向的。这时需要将rcomma转换为一个普通迭代器，能够正向移动

**通过调用reverse_iterator中的base成员函数即可完成转换，它会返回普通迭代器，但是会移动到下一位**

**从反向迭代器转化为普通迭代器会向移动到下一位，可以合理表示元素范围**

```c++
cout << string(rcomma.base(),line.cend()) << endl;
```

![](D:\office\word\计算机基础\C++\截图\反向迭代器.jpg)

### 5、泛型算法结构

任何算法的最基本特性是它要求迭代器提供哪些操作，算法所要求的迭代器操作可以分为5个迭代器类别（iterator category）

![](D:\office\word\计算机基础\C++\截图\迭代器类别.jpg)

一个高层类别的迭代器支持低层类别迭代器的所有操作

C++标准指明了泛型和数值算法的每个迭代器参数的最小类别，向算法传递一个能力更差的迭代器会产生错误。但是很多编译器不会给出警告或提示

**_if版本的算法**

```c++
find(beg,end,val); //查找val第一次出现的位置
find_if(beg,end,pred);//查找第一个令pred为真的元素
```

### 6、特定容器算法

链表类型list和forward_list定义了几个成员函数形式的算法

![](D:\office\word\计算机基础\C++\截图\链表成员函数算法.jpg)

![](D:\office\word\计算机基础\C++\截图\链表成员函数算法2.jpg)

**链表可以通过改变元素间的链接而不是真的交换它们的值来快速交换元素，因此这些链表版本的算法性能比对应的通用版本好得多。链表应该优先使用成员函数版本的算法**

**链表版本算法会改变底层的容器**

**splice成员是链表所特有的**

![](D:\office\word\计算机基础\C++\截图\splice成员.jpg)

## 十、关联容器

**关联容器和顺序容器有着根本的不同，关联容器中的元素是按照关键字来保存和访问的。而顺序容器中的元素按它们在容器中的位置来顺序保存和访问**

关联容器支持高效的关键字查找和访问，两个主要的关联容器类型是**map和set**

map中的元素是一些**关键字—值（key-value）对**。关键字起到索引的作用，值则表示与索引相关联的数据

set中每个元素只包含一个关键字，它支持高效的关键字查询操作

![](D:\office\word\计算机基础\C++\截图\关联容器类型.jpg)

**有序即插入元素时自动排序**

这八个关联容器的不同体现在三个维度：

- 要么是set，要么是map
- 要么要求不重复的关键字，要么允许重复关键字。**允许重复关键字的容器名含有multi**
- 要么按顺序保存元素，要么无序保存。**关键字无序存储的容器名以unordered开头**

因此unordered_multi_set是一个允许重复关键字，元素无序保存的集合

**无序容器使用哈希函数来组织元素**

**类型map和multimap定义在头文件map中；set和multiset定义在set中；无序容器则定义在头文件unordered_map和unordered_set中**

### 1、使用关联容器

map类型通常被叫作**关联数组**，它的下标不必是整数，通过关键字而不是位置来查找值

**set是关键字的简单集合**

#### **使用map**

map必须指定关键字和值的类型。当对word_count进行下标操作时，使用string作为下标，获得与此string相关联的size_t类型的计数器。

若word还未在map中，下标运算符会创建一个新元素，其关键字为word，值默认为0

从map中提取一个元素时，会得到一个pair类型的对象，它是模板类型，保存两个名为first和second的数据成员

**first保存关键字，second保存对应的值**

```c++
//使用map，统计每个单词在输入中出现的次数
map<string,size_t> word_count;  //string到size_t的空map
string word;
while(cin >> word)
    ++word_count[word];//对应的size_t加1
for(const auto &w : word_count)
    cout << w.first << "occurs" << w.second
    	 << ((w.second > 1) ? "times" : "time") << endl;
```

#### **使用set**

与顺序容器类似，可以对一个关联容器的元素进行列表初始化

find调用返回一个迭代器，若给定关键字在set中，则指向它；否则find返回尾后迭代器

```c++
//上面程序的改进版
map<string,size_t> word_count; 
set<string> exclude = {"The","the","And","and","Or","or"};
string word;
while(cin >> word)
    //只考虑不在exclude中的单词
    if(exclude.find(word) == exclude.end())
        ++word_count[word];
```

### 2、关联容器概述

关联容器都支持前面介绍的普通容器操作，**它不支持顺序容器中位置相关的操作，不支持构造函数或插入操作这些接受一个元素值和一个数量值的操作**

**关联容器的迭代器都是双向的**

#### 定义关联容器

定义map必须指明关键字类型和值类型；定义set必须指明关键字类型。

每个关联容器都定义了一个默认构造函数，它创建空容器。

关联容器可以初始化为另一个同类型容器的拷贝，或是从一个值范围来初始化它，只要这些值可以转化为容器所需类型

关联容器在新标准中可以值初始化。

```c++
map<string,size_t> word_count;//空容器
//列表初始化
set<string> exclude = {"The","the","And","and","Or","or"};
map<string,string> authors = {{"joyce","james"},
							  {"austen","jane"}	};
```

**初始化map时我们将每个关键字—值对包围在花括号中`{key,value}`，代表它们一起构成了一个元素**

**初始化multimap和multiset**

一个map或set中关键字必须唯一，但是multimap和multiset无此限制

```c++
//ivec包含0到9和他们每个的重复元素，一共20个
vector<int> ivec;

set<int> iset(ivec.cbegin(),ivec.cend()); //这里是10个不重复元素
multiset<int> miset(ivec.cbegin(),ivec.cend()); //包含所有20个元素

```

#### 关键字类型的要求

关联容器对其关键字类型有一些限制，无序容器后续再看

**有序容器中关键字类型必须定义元素比较的方法，默认使用<运算符来比较两个关键字**

可以自己提供一个操作来代替<运算符，这个操作必须在关键字类型上定义一个**严格弱序，即<=**

**若使用自定义操作，定义关联容器时必须提供自己定义的操作的类型，自定义的操作类型必须在尖括号中跟着元素类型后面**

**比较操作类型应该是一种函数指针类型。当定义此容器类型的对象时，需提供想要使用操作的指针**

```c++
bool compareIsbn(const Sales_data &lhs,const Sales_data &rhs){
	return lhs.isbn() < rhs.isbn();
}

multiset<Sales_data, decltype(compareIsbn) *> bookstore(compareIsbn);
multiset<Sales_data, decltype(compareIsbn) *> bookstore(&compareIsbn);//等价形式
```

#### pair类型

pair定义在头文件utility中，一个pair保存两个数据成员。**由于map内部实现涉及到pair，因此添加map头文件时会自动添加utility头文件**

pair类似容器，是用来生成特定类型的模板。创建pair时必须提供两个类型名，两个类型不要求一样

**pair默认对数据成员进行值初始化**

**pair的两个成员是public的，分别命名为first和second**

```c++
//pair默认对数据成员进行值初始化
pair<string,string> anon;  //两个空string
pair<string,size_t> word_count; //空string和0
pair<string,vector<int>> line; //空string和空vector

pair<string,string> author{"james","joyce"};//两个成员被初始化为james和joyce
```

```c++
//函数返回pair
pair<string,int> process(vector<string> &v){
    if(!v.empty())
        return {v.back(),v.back().size()};//列表初始化
    	return pair<string,int>(v.back(),v.back().size());
    	reurn make_pair(v.back(),v.back().size());//使用make_pair生成pair对象
    else
        return pair<string,int>(); //隐式构造一个空pair，调用默认构造函数生成临时对象
}

//leetcode整数转罗马数字
const pair<int,string> valSymbol[]={  //罗马数字的对照，使用pair
    {1000,"M"}, {900,"CM"}, {500,"D"}, {400,"CD"} ,{100,"C"}, {90,"XC"},{50,"L"}
    ,{40,"XL"},{10,"X"}, {9,"IX"}, {5,"V"}, {4,"IV"}, {1,"I"}
};
class Solution {
public:
    string intToRoman(int num) {
        string roman;
        for(const auto &[value,symbol] : valSymbol){ //注意此处范围for中关于pair的用法
            while(value<=num){
                    roman = roman + symbol; 
                    num = num -value;
            }
            if(num == 0) break;
        }
        return roman;
    }
};
```

### 3、关联容器操作

![](D:\office\word\计算机基础\C++\截图\关联容器中的类型别名.jpg)

对于set，key_type和value_type是一样的

**map中元素是关键字—值对，每个元素是一个pair对象，在这些pair中的关键字部分是const的**

```c++
set<string>::value_type v; //v是一个string，它的key_type也是stirng

map<string,int>::key_type v; //string类型
map<string,int>::mapped_type v; //int
map<string,int>::value_type v; //是一个pair<const string,int>，pair类型

```

#### 关联容器迭代器

**解引用关联容器迭代器时，得到value_type值的引用**

```c++
auto map_it = word_count.begin();
cout << map_it -> first;
map_it -> first = "new"; //错误！！它是const
++map_it -> second;
```

**set的迭代器时const的**

虽然set定义了iterator和const_iterator类型，但是两种类型都只能够只读访问set中的元素

```c++
set<int> iset = {0,1,2,3,4,5};
set<int>::iterator set_it = iset.begin();
*set_it = 42; //错误！！！不能修改
cout << *set_it << endl;
```

**遍历关联容器**

关联容器都支持begin和end操作。**迭代器会按照关键字升序遍历元素**

```c++
auto map_it = word_count.cbegin();
while(map_it != word_count.cend()){
    cout << map_it->first << "occurs"
        << map_it->second << "times" << endl;
    ++map_it;
}
```

**一般不对关联容器使用泛型算法**

关联容器关键字是const表示不能将它传递给修改或重排容器元素的算法，因为它们这些算法需要向元素写入值

关联容器可用于只读取元素的算法，但是这类算法需要搜索序列，关联容器中的元素不能通过关键字进行快速查找，因此使用泛型搜素算法效率不高。

若真的要使用泛型算法，一般将关联容器当做一个源序列或目的位置

#### 添加元素

![](D:\office\word\计算机基础\C++\截图\关联容器插入操作.jpg)

```c++
vector<int> ivec = {2,4,6,8,2,4};
set<int> iset;
iset.insert(ivec.begin(),ivec.end()); //重复元素不再添加
iset.insert({1,3,6,7});

//向map添加元素
word_count.insert({word,1});
word_count.insert(make_pair(word,1));
word_count.insert(pair<string,int>(word,1));
word_count.insert(map<string,int>::value_type(word,1));
```

**insert的返回值**

添加单一元素的insert和emplace返回一个pair，pair的first是一个迭代器，指向插入元素；second是一个bool值，插入成功为true

```c++
//利用insert返回值统计每个单词在输入中出现的次数
map<string,size_t> word_count;
string word;
while(cin >> word){
    auto ret = word_count.insert({word,1});//插入不重复的元素，记为1
    if(!ret.second) //若插入失败，递增计数器
        ++ret.first->second;
}

//旧版本的ret声明
pair<map<string,size_t>::iterator,bool> ret;
```

**向允许重复的关联容器添加元素**

**允许重复关键字的容器中，接收单个元素的insert返回一个指向新元素的迭代器，无需返回bool，因为总是会插入一个新元素**

比如建立同一作者对所拥有的不同书籍的映射

```c++
multimap<string,string> authors;
authors.insert({"jack","huozhe"});
authors.insert({"jack","sanguo"});
```

#### 删除元素

![](D:\office\word\计算机基础\C++\截图\关联容器删除元素.jpg)

```c++
if(word_count.erase(removal_word))
    cout << "ok";
else
    cout << "not found"; //如果是0个，则表示想删除的元素不在容器中
    
```

#### map的下标操作

![](D:\office\word\计算机基础\C++\截图\map下标操作.jpg)

**map和unordered_map容器提供了下标运算符和一个对应的at函数。不能对multimap相关的容器进行下标操作，因为他们中可能有多个值和一个关键字相关联**

map下标运算符接收一个关键字作为索引，获取与它对应的值。

**若关键字不在map中，会为它创建一个元素并插入到map，关联值会进行值初始化**

**在map中进行下标操作会获得mapped_type对象；解引用map迭代器会得到一个value_type对象**

**map下标运算符返回一个左值，与其他地方的下标运算符相同**

#### 访问元素

![](D:\office\word\计算机基础\C++\截图\关联容器查找元素1.jpg)

![](D:\office\word\计算机基础\C++\截图\关联容器查找元素2.jpg)

**更正：equal_range中若不存在，两个迭代器指向关键字可插入的位置**

**lower_bound即返回一个迭代器，指向第一个具有给定关键字的元素；而upper_bound返回一个迭代器指向最后一个匹配给定关键字的元素之后的位置；**

**若元素不在容器中，则它们返回相等的迭代器，指向给定关键字的插入点，能保持容器中元素顺序的插入位置**

**若关键字不存在，且大于容器中任何关键字，则lower_bound返回尾后迭代器**



对于不允许重复关键字的关联容器来说，查找元素很简单，要么在，要么不在

**若在multimap或multiset中多个元素具有重复的关键字，则这些元素在容器中会相邻存储**

```c++
//利用相邻存储，可以找出一个作者所拥有书的数量
string search_item("jack"); //要查找的作者名
auto entries = authors.count(search_item); //元素的数量
auto it = authors.find(search_item);
while(entries){
    cout << it->second < endl; //打印每个书名
    ++it;  //利用相邻存储指向该作者的下本
    --entries; 
}


//使用lower和upper_bound解决此问题
for(auto beg = authors.lower_bound(search_item),
    end = authors.upper_bound(search_item); beg != end; ++beg)
    cout << beg->second << endl;
```

**equal_range函数**

**它接收一个关键字，返回一个迭代器pair。pair中两个迭代器表示元素范围（左闭合），若元素不存在，两个迭代器同时指向关键字可以插入的位置**

```c++
//上面作者拥有书问题的第三种解决方法
for(auto pos = authors.equal_range(search_item);
   pos.first != pos.second; ++pos.first)
    cout << pos.first->second << endl;
```

#### 例：一个单词转换的map

给定一个string，将它转换成另一个string 

map_file每一行对应一条规则，input对应要转换的文本

```c++
void word_transform(ifstream &map_file,ifstream &input){
    auto trans_map = buildMap(map_file); //保存转换规则，生成单词转换map
    string text;
    while(getline(input,text)){
        istringstream stream(text); //读取每个单词
        string word;
        bool firstword = true; //控制是否打印空格
        while(stream >> word){
            if(firstword)
                firstword = false;
            else
                cout << " ";
            //transform返回第一个参数或转换之后的形式
            cout << transform(word,trans_map);
        }
        cout << endl; //完成一行的转换     
    }  
}

map<string,string> buildMap(ifstream &map_file){
    map<string,string> trans_map;
    string key;
    string value;
    //读取第一个单词存入key，一行中剩余内容存入value
    while(map_file >> key && getline(map_file,value)){
		if(value.size()>1)
            trans_map[key] = value.substr(1); //跳过最前面的空格
        else
            throw runtime_error("no rule for" + key);
    }
    return trans_map;
        
}


const string& transform(const string &s,const map<string,strign> &m){
    auto map_it = m.find(s);
    if(map_it != m.cend())
        return map_it->second; //进行替换
    else
        return s; //否则返回原string
}
```

### 4、无序容器

C++11定义了4个无序关联容器，它们不使用比较运算符组织元素，**而是使用哈希函数和关键字类型的==运算符**

使用无序容器通常更为简单，通常也会有更好的性能

关键字类型若本来就是无序的，或者发现问题可以用哈希技术解决，就可以使用无序容器

**无序容器还提供了与有序容器相同的操作**

```c++
//使用unordered_map，统计每个单词在输入中出现的次数
unordered_map<string,size_t> word_count;  //string到size_t的空map
string word;
while(cin >> word)
    ++word_count[word];//对应的size_t加1
for(const auto &w : word_count)
    cout << w.first << "occurs" << w.second
    	 << ((w.second > 1) ? "times" : "time") << endl;
```

#### 管理桶

无序容器在存储上组织为一组桶，每个桶保存0个或多个元素，它会使用哈希函数将元素映射到桶，计算元素的哈希值决定了它应该搜索哪个桶

容器将具有相同哈希值的元素都保存到同一桶中，若允许重复关键字，则这些重复的元素也会在同一桶中

**无序容器的性能依赖于哈希函数的质量和桶的数量、大小**

当一个桶中有多个元素时，需要顺序搜索这些元素来找到我们想要的。若桶中元素太多，则查找需要大量比较操作

```
无序容器构造：
Unord c //默认构造函数；创建一个空无序容器

Unord c(bnum) //创建一个空无序容器，内部至少使用了bnum个桶

Unord c(bnum,hf) //创建一个空无序容器，内部至少使用了bnum个桶,hf作为哈希函数

Unord c(bnum,hf,cmp) //创建一个空无序容器，内部至少使用了bnum个桶,hf作为哈希函数,cmp用来识别相等的值
```

![](D:\office\word\计算机基础\C++\截图\无序容器管理操作.jpg)

#### 无序容器对关键字类型的要求

**默认情况下无序容器使用关键字类型的==运算符来比较元素**，它们还会使用`hash<key_type>`类型的对象来生成每个元素的哈希值

标准库为内置类型（包含指针）提供了hash模板，还为一些标准库类型，包括string和智能指针类型定义了hash

**因此可以直接定义关键字是内置类型（包含指针）、string、智能指针类型的无序容器；不能直接定义关键字类型为自定义类类型的无序容器**

我们不使用默认的hash，而是使用另一种方法，类似于之前为有序容器重载关键字类型的默认比较操作

比如为了将Sales_data用作关键字，我们需要提供函数来替代==运算符和哈希值计算函数

若类定义了==运算符，则只需要重载哈希函数

```c++
size_t hasher(const Sales_data &sd){
    return hash<string>() (sd.isbn()); //这其实是标准库中哈希函数的一个重载函数调用运算符()的调用。
}

bool eqOp(cosnt Sales_data &lhs,const Sales_data &rhs){
    return lhs.isbn() == rhs.isbn();
}

//使用它们定义一个unordered_multiset，将重载的两个函数指针放入尖括号
using SD_multiset = unordered_multiset<Sales_data,
					decltype(hasher)*,decltype(eqOp)*>;
//参数是桶数目，哈希函数指针和==运算符指针
SD_multiset bookstore(42,hasher,eqOp);
```

#### **仿函数**

`return hash<string>() (sd.isbn());`

理解上面的语法，就先了解下仿函数，C++允许类重载函数调用运算符，这样的话，我们可以像使用函数一样使用该类

```c++
//定义一个对象
struct Hasher
{
	//默认构造函数
	Hasher()
	{
		cout << "Hasher default ctor" << endl;
	}
	//接受一个参数的构造函数
	Hasher(const char *str)
	{
		cout << "Hasher ctor:" << str << endl;
	}
	//重载函数调用运算符
	size_t operator() (const char *str) const
	{
		cout << "calling func:" << str << endl;
	}
};

int main(int argc, char *argv[])
{
	Hasher hasher("create obj");
	//下面这行对象调用了重载的函数运算符，就像调用函数一样
	//（类对象具有“像函数一样的行为”）
	hasher("testing  111"); 
	//仿照最开头那段代码 ---->hash<string>() ((sd.isbn))
	Hasher()("testing 222");
	return 0;
}

/*运行结果：
Hasher ctor:create obj
calling func:testing  111
Hasher default ctor
calling func:testing 222
*/
```

**注：下面这行调用默认构造函数先创建了一个临时的对象，然后再调用了重载的函数调用运算符，注意Hasher而不是hasher，C++允许直接通过类名+()来创建一个临时对象（即 “Hasher()”），它只在当前行有效。**

`Hasher()("testing 222");`

